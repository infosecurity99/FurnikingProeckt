{"ast":null,"code":"var camelCase = require('camelcase');\n\nvar path = require('path');\n\nvar tokenizeArgString = require('./lib/tokenize-arg-string');\n\nvar util = require('util');\n\nfunction parse(args, opts) {\n  if (!opts) opts = {}; // allow a string argument to be passed in rather\n  // than an argv array.\n\n  args = tokenizeArgString(args); // aliases might have transitive relationships, normalize this.\n\n  var aliases = combineAliases(opts.alias || {});\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false\n  }, opts.configuration);\n  var defaults = opts.default || {};\n  var configObjects = opts.configObjects || [];\n  var envPrefix = opts.envPrefix;\n  var notFlagsOption = configuration['populate--'];\n  var notFlagsArgv = notFlagsOption ? '--' : '_';\n  var newAliases = {}; // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments));\n  };\n\n  var error = null;\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {}\n  };\n  var negative = /^-[0-9]+(\\.[0-9]+)?/;\n  [].concat(opts.array).filter(Boolean).forEach(function (key) {\n    flags.arrays[key] = true;\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n  });\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  } // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n  extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  var argv = {\n    _: []\n  };\n  Object.keys(flags.bools).forEach(function (key) {\n    setArg(key, !(key in defaults) ? false : defaults[key]);\n    setDefaulted(key);\n  });\n  var notFlags = [];\n\n  if (args.indexOf('--') !== -1) {\n    notFlags = args.slice(args.indexOf('--') + 1);\n    args = args.slice(0, args.indexOf('--'));\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    var broken;\n    var key;\n    var letters;\n    var m;\n    var next;\n    var value; // -- seperated by =\n\n    if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // nargs format = '--f=monkey washing cat'\n\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatNargs(i, m[1], args); // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatArray(i, m[1], args);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {\n      key = arg.match(/^--no-(.+)/)[1];\n      setArg(key, false); // -- seperated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-.+/)) {\n      key = arg.match(/^--?(.+)/)[1]; // nargs format = '--foo a b c'\n\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args); // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args);\n      } else {\n        next = args[i + 1];\n\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)));\n        }\n      } // dot-notation flag seperated by '='.\n\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]); // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j]; // nargs format = '-f=monkey washing cat'\n\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value);\n            i = eatNargs(i, key, args); // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value);\n            i = eatArray(i, key, args);\n          } else {\n            setArg(key, value);\n          }\n\n          broken = true;\n          break;\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        } // current letter is an alphabetic character and next value is a number\n\n\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)));\n        }\n      }\n\n      key = arg.slice(-1)[0];\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args); // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args);\n        } else {\n          next = args[i + 1];\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)));\n          }\n        }\n      }\n    } else {\n      argv._.push(flags.strings['_'] || !isNumber(arg) ? arg : Number(arg));\n    }\n  } // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n\n\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n  applyEnvVars(argv, false);\n  setConfig(argv);\n  setConfigObjects();\n  applyDefaultsAndAliases(argv, flags.aliases, defaults);\n  applyCoercions(argv); // for any counts either not in args or without an explicit default, set to 0\n\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  }); // '--' defaults to undefined.\n\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key);\n  }); // how many arguments should we consume, based\n  // on the nargs option?\n\n  function eatNargs(i, key, args) {\n    var toEat = checkAllAliases(key, flags.nargs);\n    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key));\n\n    for (var ii = i + 1; ii < toEat + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n\n    return i + toEat;\n  } // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n  function eatArray(i, key, args) {\n    var start = i + 1;\n    var argsToSet = [];\n    var multipleArrayFlag = i > 0;\n\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'));\n        }\n\n        multipleArrayFlag = true;\n        break;\n      }\n\n      i = ii;\n      argsToSet.push(args[ii]);\n    }\n\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg);\n      }));\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg);\n      });\n    }\n\n    return i;\n  }\n\n  function setArg(key, val) {\n    unsetDefaulted(key);\n\n    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {\n      var c = camelCase(key);\n      flags.aliases[key] = [c];\n      newAliases[c] = true;\n    }\n\n    var value = processValue(key, val);\n    var splitKey = key.split('.');\n    setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    } // handle populating aliases of the first element of the dot-notation key\n\n\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.'); // expand alias with nested objects in key\n\n        var a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n\n        x = x.concat(a);\n        setKey(argv, x, value);\n      });\n    } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v);\n        });\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val;\n        });\n      });\n    }\n  }\n\n  function processValue(key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n\n    var value = val;\n\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      if (isNumber(val)) value = Number(val);\n      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN;\n    } // increment a count given as arg (either no value or value parsed as boolean)\n\n\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n\n    return value;\n  } // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n\n\n  function setConfig(argv) {\n    var configLookup = {}; // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey];\n\n      if (configPath) {\n        try {\n          var config = null;\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath);\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  } // set args from config object.\n  // it recursively checks nested objects.\n\n\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key];\n      var fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n\n      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || flags.defaulted[fullKey]) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  } // set all config objects passed in opts\n\n\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    var prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n\n          return camelCase(key);\n        });\n\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n\n  function applyCoercions(argv) {\n    var coerce;\n    Object.keys(argv).forEach(function (key) {\n      coerce = checkAllAliases(key, flags.coercions);\n\n      if (typeof coerce === 'function') {\n        try {\n          argv[key] = coerce(argv[key]);\n        } catch (err) {\n          error = err;\n        }\n      }\n    });\n  }\n\n  function applyDefaultsAndAliases(obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n\n  function hasKey(obj, keys) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    var key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n\n  function setKey(obj, keys, value) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      if (o[key] === undefined) o[key] = {};\n      o = o[key];\n    });\n    var key = keys[keys.length - 1];\n    var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n    var isValueArray = Array.isArray(value);\n    var duplicate = configuration['duplicate-arguments-array'];\n\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  } // extend the aliases list with inferred aliases.\n\n\n  function extendAliases() {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x);\n            flags.aliases[key].push(c);\n            newAliases[c] = true;\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  } // check if a flag is set for any of a key's aliases.\n\n\n  function checkAllAliases(key, flag) {\n    var isSet = false;\n    var toCheck = [].concat(flags.aliases[key] || [], key);\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key];\n    });\n    return isSet;\n  }\n\n  function setDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true;\n    });\n  }\n\n  function unsetDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k];\n    });\n  } // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n\n\n  function defaultForType(type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  } // given a flag, enforce a default type.\n\n\n  function guessType(key, flags) {\n    var type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n\n  function isNumber(x) {\n    if (!configuration['parse-numbers']) return false;\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n\n  function isUndefined(num) {\n    return num === undefined;\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  };\n} // if any aliases reference each other, we should\n// merge them together.\n\n\nfunction combineAliases(aliases) {\n  var aliasArrays = [];\n  var change = true;\n  var combined = {}; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n}\n\nfunction assign(defaults, configuration) {\n  var o = {};\n  configuration = configuration || {};\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k];\n  });\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k];\n  });\n  return o;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction Parser(args, opts) {\n  var result = parse(args.slice(), opts);\n  return result.argv;\n} // parse arguments and return detailed\n// meta information, aliases, etc.\n\n\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n};\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/yargs-parser/index.js"],"names":["camelCase","require","path","tokenizeArgString","util","parse","args","opts","aliases","combineAliases","alias","configuration","assign","defaults","default","configObjects","envPrefix","notFlagsOption","notFlagsArgv","newAliases","__","str","format","apply","Array","prototype","slice","call","arguments","error","flags","arrays","bools","strings","numbers","counts","normalize","configs","defaulted","nargs","coercions","negative","concat","array","filter","Boolean","forEach","key","boolean","string","number","count","Object","keys","narg","k","coerce","isArray","config","extendAliases","argv","_","setArg","setDefaulted","notFlags","indexOf","i","length","arg","broken","letters","m","next","value","match","checkAllAliases","splice","eatNargs","eatArray","undefined","test","defaultForType","guessType","split","j","push","isNumber","Number","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","hasKey","toEat","Error","ii","start","argsToSet","multipleArrayFlag","map","processValue","val","unsetDefaulted","c","splitKey","setKey","x","a","shift","__defineSetter__","v","__defineGetter__","isUndefined","NaN","increment","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","substring","join","err","obj","o","isTypeArray","isValueArray","duplicate","y","flag","isSet","toCheck","type","def","num","aliasArrays","change","combined","intersect","aliasArray","self","pop","orig","Parser","result","detailed","module","exports"],"mappings":"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","sourcesContent":["var camelCase = require('camelcase')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var notFlagsOption = configuration['populate--']\n  var notFlagsArgv = notFlagsOption ? '--' : '_'\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments))\n  }\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {}\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (key) {\n    flags.arrays[key] = true\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n\n  Object.keys(flags.bools).forEach(function (key) {\n    setArg(key, !(key in defaults) ? false : defaults[key])\n    setDefaulted(key)\n  })\n\n  var notFlags = []\n  if (args.indexOf('--') !== -1) {\n    notFlags = args.slice(args.indexOf('--') + 1)\n    args = args.slice(0, args.indexOf('--'))\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    // -- seperated by =\n    if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {\n      key = arg.match(/^--no-(.+)/)[1]\n      setArg(key, false)\n\n    // -- seperated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)))\n        }\n      }\n\n    // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)))\n          }\n        }\n      }\n    } else {\n      argv._.push(\n        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n      )\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var toEat = checkAllAliases(key, flags.nargs)\n\n    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    for (var ii = i + 1; ii < (toEat + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + toEat)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    var start = i + 1\n    var argsToSet = []\n    var multipleArrayFlag = i > 0\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'))\n        }\n        multipleArrayFlag = true\n        break\n      }\n      i = ii\n      argsToSet.push(args[ii])\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg)\n      }))\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg)\n      })\n    }\n\n    return i\n  }\n\n  function setArg (key, val) {\n    unsetDefaulted(key)\n\n    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {\n      var c = camelCase(key)\n      flags.aliases[key] = [c]\n      newAliases[c] = true\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function processValue (key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = val\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      if (isNumber(val)) value = Number(val)\n      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN\n    }\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    Object.keys(argv).forEach(function (key) {\n      coerce = checkAllAliases(key, flags.coercions)\n      if (typeof coerce === 'function') {\n        try {\n          argv[key] = coerce(argv[key])\n        } catch (err) {\n          error = err\n        }\n      }\n    })\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      if (o[key] === undefined) o[key] = {}\n      o = o[key]\n    })\n\n    var key = keys[keys.length - 1]\n\n    var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    var isValueArray = Array.isArray(value)\n    var duplicate = configuration['duplicate-arguments-array']\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases () {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            flags.aliases[key].push(c)\n            newAliases[c] = true\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function setDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true\n    })\n  }\n\n  function unsetDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k]\n    })\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key, flags) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (!configuration['parse-numbers']) return false\n    if (typeof x === 'number') return true\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\nfunction assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}