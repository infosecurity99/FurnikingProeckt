{"ast":null,"code":"const command = require('./command')();\n\nconst YError = require('./yerror');\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\n\nmodule.exports = function (expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    var position = 0;\n    var parsed = {\n      demanded: [],\n      optional: []\n    };\n\n    if (typeof expected === 'object') {\n      length = callerArguments;\n      callerArguments = expected;\n    } else {\n      parsed = command.parseCommand('cmd ' + expected);\n    }\n\n    const args = [].slice.call(callerArguments);\n\n    while (args.length && args[args.length - 1] === undefined) args.pop();\n\n    length = length || args.length;\n\n    if (length < parsed.demanded.length) {\n      throw new YError('Not enough arguments provided. Expected ' + parsed.demanded.length + ' but received ' + args.length + '.');\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length;\n\n    if (length > totalCommands) {\n      throw new YError('Too many arguments provided. Expected max ' + totalCommands + ' but received ' + length + '.');\n    }\n\n    parsed.demanded.forEach(function (demanded) {\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = demanded.cmd.filter(function (type) {\n        return type === observedType || type === '*';\n      });\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false);\n      position += 1;\n    });\n    parsed.optional.forEach(function (optional) {\n      if (args.length === 0) return;\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = optional.cmd.filter(function (type) {\n        return type === observedType || type === '*';\n      });\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true);\n      position += 1;\n    });\n  } catch (err) {\n    console.warn(err.stack);\n  }\n};\n\nfunction guessType(arg) {\n  if (Array.isArray(arg)) {\n    return 'array';\n  } else if (arg === null) {\n    return 'null';\n  }\n\n  return typeof arg;\n}\n\nfunction argumentTypeError(observedType, allowedTypes, position, optional) {\n  throw new YError('Invalid ' + (positionName[position] || 'manyith') + ' argument.' + ' Expected ' + allowedTypes.join(' or ') + ' but received ' + observedType + '.');\n}","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/yargs/lib/argsert.js"],"names":["command","require","YError","positionName","module","exports","expected","callerArguments","length","position","parsed","demanded","optional","parseCommand","args","slice","call","undefined","pop","totalCommands","forEach","arg","shift","observedType","guessType","matchingTypes","cmd","filter","type","argumentTypeError","err","console","warn","stack","Array","isArray","allowedTypes","join"],"mappings":"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","sourcesContent":["const command = require('./command')()\nconst YError = require('./yerror')\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']\n\nmodule.exports = function (expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    var position = 0\n    var parsed = {demanded: [], optional: []}\n    if (typeof expected === 'object') {\n      length = callerArguments\n      callerArguments = expected\n    } else {\n      parsed = command.parseCommand('cmd ' + expected)\n    }\n    const args = [].slice.call(callerArguments)\n\n    while (args.length && args[args.length - 1] === undefined) args.pop()\n    length = length || args.length\n\n    if (length < parsed.demanded.length) {\n      throw new YError('Not enough arguments provided. Expected ' + parsed.demanded.length +\n        ' but received ' + args.length + '.')\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length\n    if (length > totalCommands) {\n      throw new YError('Too many arguments provided. Expected max ' + totalCommands +\n        ' but received ' + length + '.')\n    }\n\n    parsed.demanded.forEach(function (demanded) {\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = demanded.cmd.filter(function (type) {\n        return type === observedType || type === '*'\n      })\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false)\n      position += 1\n    })\n\n    parsed.optional.forEach(function (optional) {\n      if (args.length === 0) return\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = optional.cmd.filter(function (type) {\n        return type === observedType || type === '*'\n      })\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true)\n      position += 1\n    })\n  } catch (err) {\n    console.warn(err.stack)\n  }\n}\n\nfunction guessType (arg) {\n  if (Array.isArray(arg)) {\n    return 'array'\n  } else if (arg === null) {\n    return 'null'\n  }\n  return typeof arg\n}\n\nfunction argumentTypeError (observedType, allowedTypes, position, optional) {\n  throw new YError('Invalid ' + (positionName[position] || 'manyith') + ' argument.' +\n    ' Expected ' + allowedTypes.join(' or ') + ' but received ' + observedType + '.')\n}\n"]},"metadata":{},"sourceType":"script"}