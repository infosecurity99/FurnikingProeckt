{"ast":null,"code":"const path = require('path');\n\nconst inspect = require('util').inspect;\n\nconst camelCase = require('camelcase');\n\nconst DEFAULT_MARKER = '*'; // handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\n\nmodule.exports = function (yargs, usage, validation) {\n  const self = {};\n  var handlers = {};\n  var aliasMap = {};\n  var defaultCommand;\n\n  self.addHandler = function (cmd, description, builder, handler) {\n    var aliases = [];\n\n    handler = handler || function () {};\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1);\n      cmd = cmd[0];\n    } else if (typeof cmd === 'object') {\n      var command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler);\n      return;\n    } // allow a module to be provided instead of separate builder and handler\n\n\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler);\n      return;\n    } // parse positionals out of cmd string\n\n\n    var parsedCommand = self.parseCommand(cmd); // remove positional args from aliases only\n\n    aliases = aliases.map(function (alias) {\n      return self.parseCommand(alias).cmd;\n    }); // check for default and filter out '*''\n\n    var isDefault = false;\n    var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {\n      if (c === DEFAULT_MARKER) {\n        isDefault = true;\n        return false;\n      }\n\n      return true;\n    }); // short-circuit if default with no aliases\n\n    if (isDefault && parsedAliases.length === 0) {\n      defaultCommand = {\n        original: cmd.replace(DEFAULT_MARKER, '').trim(),\n        handler: handler,\n        builder: builder || {},\n        demanded: parsedCommand.demanded,\n        optional: parsedCommand.optional\n      };\n      return;\n    } // shift cmd and aliases after filtering out '*'\n\n\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0];\n      aliases = parsedAliases.slice(1);\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n    } // populate aliasMap\n\n\n    aliases.forEach(function (alias) {\n      aliasMap[alias] = parsedCommand.cmd;\n    });\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases);\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      handler: handler,\n      builder: builder || {},\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    };\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n  };\n\n  self.addDirectory = function (dir, context, req, callerFile, opts) {\n    opts = opts || {}; // disable recursion to support nested directories of subcommands\n\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults\n\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function\n\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) {\n      return o;\n    }; // call addHandler via visitor function\n\n    opts.visit = function (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor\n\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files\n\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    require('require-directory')({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  }; // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n\n\n  function moduleName(obj) {\n    const mod = require('which-module')(obj);\n\n    if (!mod) throw new Error('No command name given for module: ' + inspect(obj));\n    return commandFromFilename(mod.filename);\n  } // derive command name from filename\n\n\n  function commandFromFilename(filename) {\n    return path.basename(filename, path.extname(filename));\n  }\n\n  function extractDesc(obj) {\n    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]];\n      if (typeof test === 'string' || typeof test === 'boolean') return test;\n    }\n\n    return false;\n  }\n\n  self.parseCommand = function (cmd) {\n    var extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    var splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    var bregex = /\\.*[\\][<>]/g;\n    var parsedCommand = {\n      cmd: splitCommand.shift().replace(bregex, ''),\n      demanded: [],\n      optional: []\n    };\n    splitCommand.forEach(function (cmd, i) {\n      var variadic = false;\n      cmd = cmd.replace(/\\s/g, '');\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;\n\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        });\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        });\n      }\n    });\n    return parsedCommand;\n  };\n\n  self.getCommands = function () {\n    return Object.keys(handlers).concat(Object.keys(aliasMap));\n  };\n\n  self.getCommandHandlers = function () {\n    return handlers;\n  };\n\n  self.hasDefaultCommand = function () {\n    return !!defaultCommand;\n  };\n\n  self.runCommand = function (command, yargs, parsed, commandIndex) {\n    var aliases = parsed.aliases;\n    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    var currentContext = yargs.getContext();\n    var numFiles = currentContext.files.length;\n    var parentCommands = currentContext.commands.slice(); // what does yargs look like after the buidler is run?\n\n    var innerArgv = parsed.argv;\n    var innerYargs = null;\n    var positionalMap = {};\n    if (command) currentContext.commands.push(command);\n\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases)); // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n\n      if (yargs.parsed === false) {\n        if (typeof yargs.getUsageInstance().getUsage() === 'undefined') {\n          yargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original);\n        }\n\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex);\n      } else {\n        innerArgv = yargs.parsed.argv;\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases;else aliases = yargs.parsed.aliases;\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases);\n      innerYargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original);\n      Object.keys(commandHandler.builder).forEach(function (key) {\n        innerYargs.option(key, commandHandler.builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs);\n    } // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n\n\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error);\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput();\n\n      commandHandler.handler(innerArgv);\n    }\n\n    if (command) currentContext.commands.pop();\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  }; // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n\n\n  function populatePositionals(commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length); // nuke the current commands\n\n    var demanded = commandHandler.demanded.slice(0);\n    var optional = commandHandler.optional.slice(0);\n    var positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      var demand = demanded.shift();\n      populatePositional(demand, argv, yargs, positionalMap);\n    }\n\n    while (optional.length) {\n      var maybe = optional.shift();\n      populatePositional(maybe, argv, yargs, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._);\n    return positionalMap;\n  } // populate a single positional argument and its\n  // aliases onto argv.\n\n\n  function populatePositional(positional, argv, yargs, positionalMap) {\n    // \"positional\" consists of the positional.cmd, an array representing\n    // the positional's name and aliases, and positional.variadic\n    // indicating whether or not it is a variadic array.\n    var variadics = null;\n    var value = null;\n\n    for (var i = 0, cmd; (cmd = positional.cmd[i]) !== undefined; i++) {\n      if (positional.variadic) {\n        if (variadics) argv[cmd] = variadics.slice(0);else argv[cmd] = variadics = argv._.splice(0);\n      } else {\n        if (!value && !argv._.length) continue;\n        if (value) argv[cmd] = value;else argv[cmd] = value = argv._.shift();\n      }\n\n      positionalMap[cmd] = true;\n      postProcessPositional(yargs, argv, cmd);\n      addCamelCaseExpansions(argv, cmd);\n    }\n  } // TODO move positional arg logic to yargs-parser and remove this duplication\n\n\n  function postProcessPositional(yargs, argv, key) {\n    var coerce = yargs.getOptions().coerce[key];\n\n    if (typeof coerce === 'function') {\n      try {\n        argv[key] = coerce(argv[key]);\n      } catch (err) {\n        yargs.getUsageInstance().fail(err.message, err);\n      }\n    }\n  }\n\n  function addCamelCaseExpansions(argv, option) {\n    if (/-/.test(option)) {\n      const cc = camelCase(option);\n      if (typeof argv[option] === 'object') argv[cc] = argv[option].slice(0);else argv[cc] = argv[option];\n    }\n  }\n\n  self.reset = function () {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  }; // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n\n\n  var frozen;\n\n  self.freeze = function () {\n    frozen = {};\n    frozen.handlers = handlers;\n    frozen.aliasMap = aliasMap;\n    frozen.defaultCommand = defaultCommand;\n  };\n\n  self.unfreeze = function () {\n    handlers = frozen.handlers;\n    aliasMap = frozen.aliasMap;\n    defaultCommand = frozen.defaultCommand;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/yargs/lib/command.js"],"names":["path","require","inspect","camelCase","DEFAULT_MARKER","module","exports","yargs","usage","validation","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","aliases","Array","isArray","slice","command","moduleName","concat","extractDesc","parsedCommand","parseCommand","map","alias","isDefault","parsedAliases","filter","c","length","original","replace","trim","demanded","optional","forEach","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","push","mod","Error","commandFromFilename","basename","extname","keys","i","l","test","extraSpacesStrippedCommand","splitCommand","split","bregex","shift","variadic","getCommands","Object","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","innerYargs","positionalMap","reset","getUsageInstance","getUsage","join","_parseArgs","key","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","pop","splice","_","positionalCount","demand","populatePositional","maybe","positional","variadics","value","undefined","postProcessPositional","addCamelCaseExpansions","coerce","getOptions","err","fail","message","cc","frozen","freeze","unfreeze"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBC,OAAhC;;AACA,MAAMC,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AAEA,MAAMG,cAAc,GAAG,GAAvB,C,CAEA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,UAAxB,EAAoC;AACnD,QAAMC,IAAI,GAAG,EAAb;AAEA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,cAAJ;;AACAH,EAAAA,IAAI,CAACI,UAAL,GAAkB,UAAUC,GAAV,EAAeC,WAAf,EAA4BC,OAA5B,EAAqCC,OAArC,EAA8C;AAC9D,QAAIC,OAAO,GAAG,EAAd;;AACAD,IAAAA,OAAO,GAAGA,OAAO,IAAI,YAAY,CAAE,CAAnC;;AAEA,QAAIE,KAAK,CAACC,OAAN,CAAcN,GAAd,CAAJ,EAAwB;AACtBI,MAAAA,OAAO,GAAGJ,GAAG,CAACO,KAAJ,CAAU,CAAV,CAAV;AACAP,MAAAA,GAAG,GAAGA,GAAG,CAAC,CAAD,CAAT;AACD,KAHD,MAGO,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAClC,UAAIQ,OAAO,GAAIH,KAAK,CAACC,OAAN,CAAcN,GAAG,CAACQ,OAAlB,KAA8B,OAAOR,GAAG,CAACQ,OAAX,KAAuB,QAAtD,GAAkER,GAAG,CAACQ,OAAtE,GAAgFC,UAAU,CAACT,GAAD,CAAxG;AACA,UAAIA,GAAG,CAACI,OAAR,EAAiBI,OAAO,GAAG,GAAGE,MAAH,CAAUF,OAAV,EAAmBE,MAAnB,CAA0BV,GAAG,CAACI,OAA9B,CAAV;AACjBT,MAAAA,IAAI,CAACI,UAAL,CAAgBS,OAAhB,EAAyBG,WAAW,CAACX,GAAD,CAApC,EAA2CA,GAAG,CAACE,OAA/C,EAAwDF,GAAG,CAACG,OAA5D;AACA;AACD,KAZ6D,CAc9D;;;AACA,QAAI,OAAOD,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACA,OAAvC,IAAkD,OAAOA,OAAO,CAACC,OAAf,KAA2B,UAAjF,EAA6F;AAC3FR,MAAAA,IAAI,CAACI,UAAL,CAAgB,CAACC,GAAD,EAAMU,MAAN,CAAaN,OAAb,CAAhB,EAAuCH,WAAvC,EAAoDC,OAAO,CAACA,OAA5D,EAAqEA,OAAO,CAACC,OAA7E;AACA;AACD,KAlB6D,CAoB9D;;;AACA,QAAIS,aAAa,GAAGjB,IAAI,CAACkB,YAAL,CAAkBb,GAAlB,CAApB,CArB8D,CAuB9D;;AACAI,IAAAA,OAAO,GAAGA,OAAO,CAACU,GAAR,CAAY,UAAUC,KAAV,EAAiB;AACrC,aAAOpB,IAAI,CAACkB,YAAL,CAAkBE,KAAlB,EAAyBf,GAAhC;AACD,KAFS,CAAV,CAxB8D,CA4B9D;;AACA,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,aAAa,GAAG,CAACL,aAAa,CAACZ,GAAf,EAAoBU,MAApB,CAA2BN,OAA3B,EAAoCc,MAApC,CAA2C,UAAUC,CAAV,EAAa;AAC1E,UAAIA,CAAC,KAAK9B,cAAV,EAA0B;AACxB2B,QAAAA,SAAS,GAAG,IAAZ;AACA,eAAO,KAAP;AACD;;AACD,aAAO,IAAP;AACD,KANmB,CAApB,CA9B8D,CAsC9D;;AACA,QAAIA,SAAS,IAAIC,aAAa,CAACG,MAAd,KAAyB,CAA1C,EAA6C;AAC3CtB,MAAAA,cAAc,GAAG;AACfuB,QAAAA,QAAQ,EAAErB,GAAG,CAACsB,OAAJ,CAAYjC,cAAZ,EAA4B,EAA5B,EAAgCkC,IAAhC,EADK;AAEfpB,QAAAA,OAAO,EAAEA,OAFM;AAGfD,QAAAA,OAAO,EAAEA,OAAO,IAAI,EAHL;AAIfsB,QAAAA,QAAQ,EAAEZ,aAAa,CAACY,QAJT;AAKfC,QAAAA,QAAQ,EAAEb,aAAa,CAACa;AALT,OAAjB;AAOA;AACD,KAhD6D,CAkD9D;;;AACA,QAAIT,SAAJ,EAAe;AACbJ,MAAAA,aAAa,CAACZ,GAAd,GAAoBiB,aAAa,CAAC,CAAD,CAAjC;AACAb,MAAAA,OAAO,GAAGa,aAAa,CAACV,KAAd,CAAoB,CAApB,CAAV;AACAP,MAAAA,GAAG,GAAGA,GAAG,CAACsB,OAAJ,CAAYjC,cAAZ,EAA4BuB,aAAa,CAACZ,GAA1C,CAAN;AACD,KAvD6D,CAyD9D;;;AACAI,IAAAA,OAAO,CAACsB,OAAR,CAAgB,UAAUX,KAAV,EAAiB;AAC/BlB,MAAAA,QAAQ,CAACkB,KAAD,CAAR,GAAkBH,aAAa,CAACZ,GAAhC;AACD,KAFD;;AAIA,QAAIC,WAAW,KAAK,KAApB,EAA2B;AACzBR,MAAAA,KAAK,CAACe,OAAN,CAAcR,GAAd,EAAmBC,WAAnB,EAAgCe,SAAhC,EAA2CZ,OAA3C;AACD;;AAEDR,IAAAA,QAAQ,CAACgB,aAAa,CAACZ,GAAf,CAAR,GAA8B;AAC5BqB,MAAAA,QAAQ,EAAErB,GADkB;AAE5BG,MAAAA,OAAO,EAAEA,OAFmB;AAG5BD,MAAAA,OAAO,EAAEA,OAAO,IAAI,EAHQ;AAI5BsB,MAAAA,QAAQ,EAAEZ,aAAa,CAACY,QAJI;AAK5BC,MAAAA,QAAQ,EAAEb,aAAa,CAACa;AALI,KAA9B;AAQA,QAAIT,SAAJ,EAAelB,cAAc,GAAGF,QAAQ,CAACgB,aAAa,CAACZ,GAAf,CAAzB;AAChB,GA3ED;;AA6EAL,EAAAA,IAAI,CAACgC,YAAL,GAAoB,UAAUC,GAAV,EAAeC,OAAf,EAAwBC,GAAxB,EAA6BC,UAA7B,EAAyCC,IAAzC,EAA+C;AACjEA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf,CADiE,CAEjE;;AACA,QAAI,OAAOA,IAAI,CAACC,OAAZ,KAAwB,SAA5B,EAAuCD,IAAI,CAACC,OAAL,GAAe,KAAf,CAH0B,CAIjE;;AACA,QAAI,CAAC5B,KAAK,CAACC,OAAN,CAAc0B,IAAI,CAACE,UAAnB,CAAL,EAAqCF,IAAI,CAACE,UAAL,GAAkB,CAAC,IAAD,CAAlB,CAL4B,CAMjE;;AACA,UAAMC,WAAW,GAAG,OAAOH,IAAI,CAACI,KAAZ,KAAsB,UAAtB,GAAmCJ,IAAI,CAACI,KAAxC,GAAgD,UAAUC,CAAV,EAAa;AAAE,aAAOA,CAAP;AAAU,KAA7F,CAPiE,CAQjE;;AACAL,IAAAA,IAAI,CAACI,KAAL,GAAa,UAAUE,GAAV,EAAeC,MAAf,EAAuBC,QAAvB,EAAiC;AAC5C,YAAMC,OAAO,GAAGN,WAAW,CAACG,GAAD,EAAMC,MAAN,EAAcC,QAAd,CAA3B,CAD4C,CAE5C;;AACA,UAAIC,OAAJ,EAAa;AACX;AACA;AACA,YAAI,CAACZ,OAAO,CAACa,KAAR,CAAcC,OAAd,CAAsBJ,MAAtB,CAAL,EAAoC,OAAOE,OAAP,CAHzB,CAIX;;AACAZ,QAAAA,OAAO,CAACa,KAAR,CAAcE,IAAd,CAAmBL,MAAnB;AACA5C,QAAAA,IAAI,CAACI,UAAL,CAAgB0C,OAAhB;AACD;;AACD,aAAOA,OAAP;AACD,KAZD;;AAaAvD,IAAAA,OAAO,CAAC,mBAAD,CAAP,CAA6B;AAAEA,MAAAA,OAAO,EAAE4C,GAAX;AAAgBU,MAAAA,QAAQ,EAAET;AAA1B,KAA7B,EAAqEH,GAArE,EAA0EI,IAA1E;AACD,GAvBD,CAnFmD,CA4GnD;AACA;;;AACA,WAASvB,UAAT,CAAqB6B,GAArB,EAA0B;AACxB,UAAMO,GAAG,GAAG3D,OAAO,CAAC,cAAD,CAAP,CAAwBoD,GAAxB,CAAZ;;AACA,QAAI,CAACO,GAAL,EAAU,MAAM,IAAIC,KAAJ,CAAU,uCAAuC3D,OAAO,CAACmD,GAAD,CAAxD,CAAN;AACV,WAAOS,mBAAmB,CAACF,GAAG,CAACL,QAAL,CAA1B;AACD,GAlHkD,CAoHnD;;;AACA,WAASO,mBAAT,CAA8BP,QAA9B,EAAwC;AACtC,WAAOvD,IAAI,CAAC+D,QAAL,CAAcR,QAAd,EAAwBvD,IAAI,CAACgE,OAAL,CAAaT,QAAb,CAAxB,CAAP;AACD;;AAED,WAAS7B,WAAT,CAAsB2B,GAAtB,EAA2B;AACzB,SAAK,IAAIY,IAAI,GAAG,CAAC,UAAD,EAAa,aAAb,EAA4B,MAA5B,CAAX,EAAgDC,CAAC,GAAG,CAApD,EAAuDC,CAAC,GAAGF,IAAI,CAAC9B,MAAhE,EAAwEiC,IAA7E,EAAmFF,CAAC,GAAGC,CAAvF,EAA0FD,CAAC,EAA3F,EAA+F;AAC7FE,MAAAA,IAAI,GAAGf,GAAG,CAACY,IAAI,CAACC,CAAD,CAAL,CAAV;AACA,UAAI,OAAOE,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,SAAhD,EAA2D,OAAOA,IAAP;AAC5D;;AACD,WAAO,KAAP;AACD;;AAED1D,EAAAA,IAAI,CAACkB,YAAL,GAAoB,UAAUb,GAAV,EAAe;AACjC,QAAIsD,0BAA0B,GAAGtD,GAAG,CAACsB,OAAJ,CAAY,SAAZ,EAAuB,GAAvB,CAAjC;AACA,QAAIiC,YAAY,GAAGD,0BAA0B,CAACE,KAA3B,CAAiC,sBAAjC,CAAnB;AACA,QAAIC,MAAM,GAAG,aAAb;AACA,QAAI7C,aAAa,GAAG;AAClBZ,MAAAA,GAAG,EAAGuD,YAAY,CAACG,KAAb,EAAD,CAAuBpC,OAAvB,CAA+BmC,MAA/B,EAAuC,EAAvC,CADa;AAElBjC,MAAAA,QAAQ,EAAE,EAFQ;AAGlBC,MAAAA,QAAQ,EAAE;AAHQ,KAApB;AAKA8B,IAAAA,YAAY,CAAC7B,OAAb,CAAqB,UAAU1B,GAAV,EAAemD,CAAf,EAAkB;AACrC,UAAIQ,QAAQ,GAAG,KAAf;AACA3D,MAAAA,GAAG,GAAGA,GAAG,CAACsB,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAN;AACA,UAAI,WAAW+B,IAAX,CAAgBrD,GAAhB,KAAwBmD,CAAC,KAAKI,YAAY,CAACnC,MAAb,GAAsB,CAAxD,EAA2DuC,QAAQ,GAAG,IAAX;;AAC3D,UAAI,MAAMN,IAAN,CAAWrD,GAAX,CAAJ,EAAqB;AACnBY,QAAAA,aAAa,CAACa,QAAd,CAAuBmB,IAAvB,CAA4B;AAC1B5C,UAAAA,GAAG,EAAEA,GAAG,CAACsB,OAAJ,CAAYmC,MAAZ,EAAoB,EAApB,EAAwBD,KAAxB,CAA8B,GAA9B,CADqB;AAE1BG,UAAAA,QAAQ,EAAEA;AAFgB,SAA5B;AAID,OALD,MAKO;AACL/C,QAAAA,aAAa,CAACY,QAAd,CAAuBoB,IAAvB,CAA4B;AAC1B5C,UAAAA,GAAG,EAAEA,GAAG,CAACsB,OAAJ,CAAYmC,MAAZ,EAAoB,EAApB,EAAwBD,KAAxB,CAA8B,GAA9B,CADqB;AAE1BG,UAAAA,QAAQ,EAAEA;AAFgB,SAA5B;AAID;AACF,KAfD;AAgBA,WAAO/C,aAAP;AACD,GA1BD;;AA4BAjB,EAAAA,IAAI,CAACiE,WAAL,GAAmB,YAAY;AAC7B,WAAOC,MAAM,CAACX,IAAP,CAAYtD,QAAZ,EAAsBc,MAAtB,CAA6BmD,MAAM,CAACX,IAAP,CAAYrD,QAAZ,CAA7B,CAAP;AACD,GAFD;;AAIAF,EAAAA,IAAI,CAACmE,kBAAL,GAA0B,YAAY;AACpC,WAAOlE,QAAP;AACD,GAFD;;AAIAD,EAAAA,IAAI,CAACoE,iBAAL,GAAyB,YAAY;AACnC,WAAO,CAAC,CAACjE,cAAT;AACD,GAFD;;AAIAH,EAAAA,IAAI,CAACqE,UAAL,GAAkB,UAAUxD,OAAV,EAAmBhB,KAAnB,EAA0ByE,MAA1B,EAAkCC,YAAlC,EAAgD;AAChE,QAAI9D,OAAO,GAAG6D,MAAM,CAAC7D,OAArB;AACA,QAAI+D,cAAc,GAAGvE,QAAQ,CAACY,OAAD,CAAR,IAAqBZ,QAAQ,CAACC,QAAQ,CAACW,OAAD,CAAT,CAA7B,IAAoDV,cAAzE;AACA,QAAIsE,cAAc,GAAG5E,KAAK,CAAC6E,UAAN,EAArB;AACA,QAAIC,QAAQ,GAAGF,cAAc,CAAC1B,KAAf,CAAqBtB,MAApC;AACA,QAAImD,cAAc,GAAGH,cAAc,CAACI,QAAf,CAAwBjE,KAAxB,EAArB,CALgE,CAOhE;;AACA,QAAIkE,SAAS,GAAGR,MAAM,CAACS,IAAvB;AACA,QAAIC,UAAU,GAAG,IAAjB;AACA,QAAIC,aAAa,GAAG,EAApB;AAEA,QAAIpE,OAAJ,EAAa4D,cAAc,CAACI,QAAf,CAAwB5B,IAAxB,CAA6BpC,OAA7B;;AACb,QAAI,OAAO2D,cAAc,CAACjE,OAAtB,KAAkC,UAAtC,EAAkD;AAChD;AACA;AACAyE,MAAAA,UAAU,GAAGR,cAAc,CAACjE,OAAf,CAAuBV,KAAK,CAACqF,KAAN,CAAYZ,MAAM,CAAC7D,OAAnB,CAAvB,CAAb,CAHgD,CAIhD;AACA;AACA;AACA;;AACA,UAAIZ,KAAK,CAACyE,MAAN,KAAiB,KAArB,EAA4B;AAC1B,YAAI,OAAOzE,KAAK,CAACsF,gBAAN,GAAyBC,QAAzB,EAAP,KAA+C,WAAnD,EAAgE;AAC9DvF,UAAAA,KAAK,CAACC,KAAN,CAAY,SAAS8E,cAAc,CAACnD,MAAf,GAAwBmD,cAAc,CAACS,IAAf,CAAoB,GAApB,IAA2B,GAAnD,GAAyD,EAAlE,IAAwEb,cAAc,CAAC9C,QAAnG;AACD;;AACDoD,QAAAA,SAAS,GAAGE,UAAU,GAAGA,UAAU,CAACM,UAAX,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,EAAwCf,YAAxC,CAAH,GAA2D1E,KAAK,CAACyF,UAAN,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B,IAA7B,EAAmCf,YAAnC,CAAjF;AACD,OALD,MAKO;AACLO,QAAAA,SAAS,GAAGjF,KAAK,CAACyE,MAAN,CAAaS,IAAzB;AACD;;AAED,UAAIC,UAAU,IAAInF,KAAK,CAACyE,MAAN,KAAiB,KAAnC,EAA0C7D,OAAO,GAAGuE,UAAU,CAACV,MAAX,CAAkB7D,OAA5B,CAA1C,KACKA,OAAO,GAAGZ,KAAK,CAACyE,MAAN,CAAa7D,OAAvB;AACN,KAnBD,MAmBO,IAAI,OAAO+D,cAAc,CAACjE,OAAtB,KAAkC,QAAtC,EAAgD;AACrD;AACA;AACAyE,MAAAA,UAAU,GAAGnF,KAAK,CAACqF,KAAN,CAAYZ,MAAM,CAAC7D,OAAnB,CAAb;AACAuE,MAAAA,UAAU,CAAClF,KAAX,CAAiB,SAAS8E,cAAc,CAACnD,MAAf,GAAwBmD,cAAc,CAACS,IAAf,CAAoB,GAApB,IAA2B,GAAnD,GAAyD,EAAlE,IAAwEb,cAAc,CAAC9C,QAAxG;AACAwC,MAAAA,MAAM,CAACX,IAAP,CAAYiB,cAAc,CAACjE,OAA3B,EAAoCwB,OAApC,CAA4C,UAAUwD,GAAV,EAAe;AACzDP,QAAAA,UAAU,CAACQ,MAAX,CAAkBD,GAAlB,EAAuBf,cAAc,CAACjE,OAAf,CAAuBgF,GAAvB,CAAvB;AACD,OAFD;AAGAT,MAAAA,SAAS,GAAGE,UAAU,CAACM,UAAX,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,EAAwCf,YAAxC,CAAZ;AACA9D,MAAAA,OAAO,GAAGuE,UAAU,CAACV,MAAX,CAAkB7D,OAA5B;AACD;;AAED,QAAI,CAACZ,KAAK,CAAC4F,UAAN,EAAL,EAAyB;AACvBR,MAAAA,aAAa,GAAGS,mBAAmB,CAAClB,cAAD,EAAiBM,SAAjB,EAA4BL,cAA5B,EAA4C5E,KAA5C,CAAnC;AACD,KA9C+D,CAgDhE;AACA;;;AACA,QAAI,CAACA,KAAK,CAAC4F,UAAN,EAAL,EAAyB5F,KAAK,CAAC8F,cAAN,CAAqBb,SAArB,EAAgCrE,OAAhC,EAAyCwE,aAAzC,EAAwDpF,KAAK,CAACyE,MAAN,CAAasB,KAArE;;AAEzB,QAAIpB,cAAc,CAAChE,OAAf,IAA0B,CAACX,KAAK,CAAC4F,UAAN,EAA/B,EAAmD;AACjD5F,MAAAA,KAAK,CAACgG,aAAN;;AACArB,MAAAA,cAAc,CAAChE,OAAf,CAAuBsE,SAAvB;AACD;;AAED,QAAIjE,OAAJ,EAAa4D,cAAc,CAACI,QAAf,CAAwBiB,GAAxB;AACbnB,IAAAA,QAAQ,GAAGF,cAAc,CAAC1B,KAAf,CAAqBtB,MAArB,GAA8BkD,QAAzC;AACA,QAAIA,QAAQ,GAAG,CAAf,EAAkBF,cAAc,CAAC1B,KAAf,CAAqBgD,MAArB,CAA4BpB,QAAQ,GAAG,CAAC,CAAxC,EAA2CA,QAA3C;AAElB,WAAOG,SAAP;AACD,GA9DD,CAzKmD,CAyOnD;AACA;;;AACA,WAASY,mBAAT,CAA8BlB,cAA9B,EAA8CO,IAA9C,EAAoD7C,OAApD,EAA6DrC,KAA7D,EAAoE;AAClEkF,IAAAA,IAAI,CAACiB,CAAL,GAASjB,IAAI,CAACiB,CAAL,CAAOpF,KAAP,CAAasB,OAAO,CAAC2C,QAAR,CAAiBpD,MAA9B,CAAT,CADkE,CACnB;;AAC/C,QAAII,QAAQ,GAAG2C,cAAc,CAAC3C,QAAf,CAAwBjB,KAAxB,CAA8B,CAA9B,CAAf;AACA,QAAIkB,QAAQ,GAAG0C,cAAc,CAAC1C,QAAf,CAAwBlB,KAAxB,CAA8B,CAA9B,CAAf;AACA,QAAIqE,aAAa,GAAG,EAApB;AAEAlF,IAAAA,UAAU,CAACkG,eAAX,CAA2BpE,QAAQ,CAACJ,MAApC,EAA4CsD,IAAI,CAACiB,CAAL,CAAOvE,MAAnD;;AAEA,WAAOI,QAAQ,CAACJ,MAAhB,EAAwB;AACtB,UAAIyE,MAAM,GAAGrE,QAAQ,CAACkC,KAAT,EAAb;AACAoC,MAAAA,kBAAkB,CAACD,MAAD,EAASnB,IAAT,EAAelF,KAAf,EAAsBoF,aAAtB,CAAlB;AACD;;AAED,WAAOnD,QAAQ,CAACL,MAAhB,EAAwB;AACtB,UAAI2E,KAAK,GAAGtE,QAAQ,CAACiC,KAAT,EAAZ;AACAoC,MAAAA,kBAAkB,CAACC,KAAD,EAAQrB,IAAR,EAAclF,KAAd,EAAqBoF,aAArB,CAAlB;AACD;;AAEDF,IAAAA,IAAI,CAACiB,CAAL,GAAS9D,OAAO,CAAC2C,QAAR,CAAiB9D,MAAjB,CAAwBgE,IAAI,CAACiB,CAA7B,CAAT;AACA,WAAOf,aAAP;AACD,GA/PkD,CAiQnD;AACA;;;AACA,WAASkB,kBAAT,CAA6BE,UAA7B,EAAyCtB,IAAzC,EAA+ClF,KAA/C,EAAsDoF,aAAtD,EAAqE;AACnE;AACA;AACA;AACA,QAAIqB,SAAS,GAAG,IAAhB;AACA,QAAIC,KAAK,GAAG,IAAZ;;AACA,SAAK,IAAI/C,CAAC,GAAG,CAAR,EAAWnD,GAAhB,EAAqB,CAACA,GAAG,GAAGgG,UAAU,CAAChG,GAAX,CAAemD,CAAf,CAAP,MAA8BgD,SAAnD,EAA8DhD,CAAC,EAA/D,EAAmE;AACjE,UAAI6C,UAAU,CAACrC,QAAf,EAAyB;AACvB,YAAIsC,SAAJ,EAAevB,IAAI,CAAC1E,GAAD,CAAJ,GAAYiG,SAAS,CAAC1F,KAAV,CAAgB,CAAhB,CAAZ,CAAf,KACKmE,IAAI,CAAC1E,GAAD,CAAJ,GAAYiG,SAAS,GAAGvB,IAAI,CAACiB,CAAL,CAAOD,MAAP,CAAc,CAAd,CAAxB;AACN,OAHD,MAGO;AACL,YAAI,CAACQ,KAAD,IAAU,CAACxB,IAAI,CAACiB,CAAL,CAAOvE,MAAtB,EAA8B;AAC9B,YAAI8E,KAAJ,EAAWxB,IAAI,CAAC1E,GAAD,CAAJ,GAAYkG,KAAZ,CAAX,KACKxB,IAAI,CAAC1E,GAAD,CAAJ,GAAYkG,KAAK,GAAGxB,IAAI,CAACiB,CAAL,CAAOjC,KAAP,EAApB;AACN;;AACDkB,MAAAA,aAAa,CAAC5E,GAAD,CAAb,GAAqB,IAArB;AACAoG,MAAAA,qBAAqB,CAAC5G,KAAD,EAAQkF,IAAR,EAAc1E,GAAd,CAArB;AACAqG,MAAAA,sBAAsB,CAAC3B,IAAD,EAAO1E,GAAP,CAAtB;AACD;AACF,GAtRkD,CAwRnD;;;AACA,WAASoG,qBAAT,CAAgC5G,KAAhC,EAAuCkF,IAAvC,EAA6CQ,GAA7C,EAAkD;AAChD,QAAIoB,MAAM,GAAG9G,KAAK,CAAC+G,UAAN,GAAmBD,MAAnB,CAA0BpB,GAA1B,CAAb;;AACA,QAAI,OAAOoB,MAAP,KAAkB,UAAtB,EAAkC;AAChC,UAAI;AACF5B,QAAAA,IAAI,CAACQ,GAAD,CAAJ,GAAYoB,MAAM,CAAC5B,IAAI,CAACQ,GAAD,CAAL,CAAlB;AACD,OAFD,CAEE,OAAOsB,GAAP,EAAY;AACZhH,QAAAA,KAAK,CAACsF,gBAAN,GAAyB2B,IAAzB,CAA8BD,GAAG,CAACE,OAAlC,EAA2CF,GAA3C;AACD;AACF;AACF;;AAED,WAASH,sBAAT,CAAiC3B,IAAjC,EAAuCS,MAAvC,EAA+C;AAC7C,QAAI,IAAI9B,IAAJ,CAAS8B,MAAT,CAAJ,EAAsB;AACpB,YAAMwB,EAAE,GAAGvH,SAAS,CAAC+F,MAAD,CAApB;AACA,UAAI,OAAOT,IAAI,CAACS,MAAD,CAAX,KAAwB,QAA5B,EAAsCT,IAAI,CAACiC,EAAD,CAAJ,GAAWjC,IAAI,CAACS,MAAD,CAAJ,CAAa5E,KAAb,CAAmB,CAAnB,CAAX,CAAtC,KACKmE,IAAI,CAACiC,EAAD,CAAJ,GAAWjC,IAAI,CAACS,MAAD,CAAf;AACN;AACF;;AAEDxF,EAAAA,IAAI,CAACkF,KAAL,GAAa,YAAY;AACvBjF,IAAAA,QAAQ,GAAG,EAAX;AACAC,IAAAA,QAAQ,GAAG,EAAX;AACAC,IAAAA,cAAc,GAAGqG,SAAjB;AACA,WAAOxG,IAAP;AACD,GALD,CA5SmD,CAmTnD;AACA;AACA;AACA;;;AACA,MAAIiH,MAAJ;;AACAjH,EAAAA,IAAI,CAACkH,MAAL,GAAc,YAAY;AACxBD,IAAAA,MAAM,GAAG,EAAT;AACAA,IAAAA,MAAM,CAAChH,QAAP,GAAkBA,QAAlB;AACAgH,IAAAA,MAAM,CAAC/G,QAAP,GAAkBA,QAAlB;AACA+G,IAAAA,MAAM,CAAC9G,cAAP,GAAwBA,cAAxB;AACD,GALD;;AAMAH,EAAAA,IAAI,CAACmH,QAAL,GAAgB,YAAY;AAC1BlH,IAAAA,QAAQ,GAAGgH,MAAM,CAAChH,QAAlB;AACAC,IAAAA,QAAQ,GAAG+G,MAAM,CAAC/G,QAAlB;AACAC,IAAAA,cAAc,GAAG8G,MAAM,CAAC9G,cAAxB;AACA8G,IAAAA,MAAM,GAAGT,SAAT;AACD,GALD;;AAOA,SAAOxG,IAAP;AACD,CAtUD","sourcesContent":["const path = require('path')\nconst inspect = require('util').inspect\nconst camelCase = require('camelcase')\n\nconst DEFAULT_MARKER = '*'\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function (yargs, usage, validation) {\n  const self = {}\n\n  var handlers = {}\n  var aliasMap = {}\n  var defaultCommand\n  self.addHandler = function (cmd, description, builder, handler) {\n    var aliases = []\n    handler = handler || function () {}\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      var command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler)\n      return\n    }\n\n    // parse positionals out of cmd string\n    var parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(function (alias) {\n      return self.parseCommand(alias).cmd\n    })\n\n    // check for default and filter out '*''\n    var isDefault = false\n    var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {\n      if (c === DEFAULT_MARKER) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // short-circuit if default with no aliases\n    if (isDefault && parsedAliases.length === 0) {\n      defaultCommand = {\n        original: cmd.replace(DEFAULT_MARKER, '').trim(),\n        handler: handler,\n        builder: builder || {},\n        demanded: parsedCommand.demanded,\n        optional: parsedCommand.optional\n      }\n      return\n    }\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach(function (alias) {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      handler: handler,\n      builder: builder || {},\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) { return o }\n    // call addHandler via visitor function\n    opts.visit = function (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error('No command name given for module: ' + inspect(obj))\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function (cmd) {\n    var extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    var splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    var bregex = /\\.*[\\][<>]/g\n    var parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach(function (cmd, i) {\n      var variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = function () {\n    return Object.keys(handlers).concat(Object.keys(aliasMap))\n  }\n\n  self.getCommandHandlers = function () {\n    return handlers\n  }\n\n  self.hasDefaultCommand = function () {\n    return !!defaultCommand\n  }\n\n  self.runCommand = function (command, yargs, parsed, commandIndex) {\n    var aliases = parsed.aliases\n    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    var currentContext = yargs.getContext()\n    var numFiles = currentContext.files.length\n    var parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the buidler is run?\n    var innerArgv = parsed.argv\n    var innerYargs = null\n    var positionalMap = {}\n\n    if (command) currentContext.commands.push(command)\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n      if (yargs.parsed === false) {\n        if (typeof yargs.getUsageInstance().getUsage() === 'undefined') {\n          yargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n        }\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases\n      else aliases = yargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      innerYargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n      Object.keys(commandHandler.builder).forEach(function (key) {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n      commandHandler.handler(innerArgv)\n    }\n\n    if (command) currentContext.commands.pop()\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    var demanded = commandHandler.demanded.slice(0)\n    var optional = commandHandler.optional.slice(0)\n    var positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      var demand = demanded.shift()\n      populatePositional(demand, argv, yargs, positionalMap)\n    }\n\n    while (optional.length) {\n      var maybe = optional.shift()\n      populatePositional(maybe, argv, yargs, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n    return positionalMap\n  }\n\n  // populate a single positional argument and its\n  // aliases onto argv.\n  function populatePositional (positional, argv, yargs, positionalMap) {\n    // \"positional\" consists of the positional.cmd, an array representing\n    // the positional's name and aliases, and positional.variadic\n    // indicating whether or not it is a variadic array.\n    var variadics = null\n    var value = null\n    for (var i = 0, cmd; (cmd = positional.cmd[i]) !== undefined; i++) {\n      if (positional.variadic) {\n        if (variadics) argv[cmd] = variadics.slice(0)\n        else argv[cmd] = variadics = argv._.splice(0)\n      } else {\n        if (!value && !argv._.length) continue\n        if (value) argv[cmd] = value\n        else argv[cmd] = value = argv._.shift()\n      }\n      positionalMap[cmd] = true\n      postProcessPositional(yargs, argv, cmd)\n      addCamelCaseExpansions(argv, cmd)\n    }\n  }\n\n  // TODO move positional arg logic to yargs-parser and remove this duplication\n  function postProcessPositional (yargs, argv, key) {\n    var coerce = yargs.getOptions().coerce[key]\n    if (typeof coerce === 'function') {\n      try {\n        argv[key] = coerce(argv[key])\n      } catch (err) {\n        yargs.getUsageInstance().fail(err.message, err)\n      }\n    }\n  }\n\n  function addCamelCaseExpansions (argv, option) {\n    if (/-/.test(option)) {\n      const cc = camelCase(option)\n      if (typeof argv[option] === 'object') argv[cc] = argv[option].slice(0)\n      else argv[cc] = argv[option]\n    }\n  }\n\n  self.reset = function () {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = function () {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n    frozen = undefined\n  }\n\n  return self\n}\n"]},"metadata":{},"sourceType":"script"}