{"ast":null,"code":"const argsert = require('./lib/argsert');\n\nconst assign = require('./lib/assign');\n\nconst Command = require('./lib/command');\n\nconst Completion = require('./lib/completion');\n\nconst Parser = require('yargs-parser');\n\nconst path = require('path');\n\nconst Usage = require('./lib/usage');\n\nconst Validation = require('./lib/validation');\n\nconst Y18n = require('y18n');\n\nconst objFilter = require('./lib/obj-filter');\n\nconst setBlocking = require('set-blocking');\n\nconst applyExtends = require('./lib/apply-extends');\n\nconst YError = require('./lib/yerror');\n\nvar exports = module.exports = Yargs;\n\nfunction Yargs(processArgs, cwd, parentRequire) {\n  processArgs = processArgs || []; // handle calling yargs().\n\n  const self = {};\n  var command = null;\n  var completion = null;\n  var groups = {};\n  var output = '';\n  var preservedGroups = {};\n  var usage = null;\n  var validation = null;\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  });\n  if (!cwd) cwd = process.cwd();\n  self.$0 = process.argv.slice(0, 2).map(function (x, i) {\n    // ignore the node bin, specify this in your\n    // bin file with #!/usr/bin/env node\n    if (i === 0 && /\\b(node|iojs)(\\.exe)?$/.test(x)) return;\n    var b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(path.dirname(process.execPath) + '/', '');\n  } // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n\n\n  const context = {\n    resets: -1,\n    commands: [],\n    files: []\n  };\n\n  self.getContext = function () {\n    return context;\n  }; // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n\n\n  var options;\n\n  self.resetOptions = self.reset = function (aliases) {\n    context.resets++;\n    aliases = aliases || {};\n    options = options || {}; // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n\n    var tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []; // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n\n    var localLookup = {};\n    tmpOptions.local.forEach(function (l) {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(function (a) {\n        localLookup[a] = true;\n      });\n    }); // preserve all groups not set to local.\n\n    preservedGroups = Object.keys(groups).reduce(function (acc, groupName) {\n      var keys = groups[groupName].filter(function (key) {\n        return !(key in localLookup);\n      });\n\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n\n      return acc;\n    }, {}); // groups can now be reset\n\n    groups = {};\n    var arrayOptions = ['array', 'boolean', 'string', 'requiresArg', 'skipValidation', 'count', 'normalize', 'number'];\n    var objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'];\n    arrayOptions.forEach(function (k) {\n      tmpOptions[k] = (options[k] || []).filter(function (k) {\n        return !localLookup[k];\n      });\n    });\n    objectOptions.forEach(function (k) {\n      tmpOptions[k] = objFilter(options[k], function (k, v) {\n        return !localLookup[k];\n      });\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions; // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n);\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n);\n    command = command ? command.reset() : Command(self, usage, validation);\n    if (!completion) completion = Completion(self, usage, command);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n\n  self.resetOptions(); // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n\n  var frozen;\n\n  function freeze() {\n    frozen = {};\n    frozen.options = options;\n    frozen.configObjects = options.configObjects.slice(0);\n    frozen.exitProcess = exitProcess;\n    frozen.groups = groups;\n    usage.freeze();\n    validation.freeze();\n    command.freeze();\n    frozen.strict = strict;\n    frozen.completionCommand = completionCommand;\n    frozen.output = output;\n    frozen.exitError = exitError;\n    frozen.hasOutput = hasOutput;\n    frozen.parsed = self.parsed;\n  }\n\n  function unfreeze() {\n    options = frozen.options;\n    options.configObjects = frozen.configObjects;\n    exitProcess = frozen.exitProcess;\n    groups = frozen.groups;\n    output = frozen.output;\n    exitError = frozen.exitError;\n    hasOutput = frozen.hasOutput;\n    self.parsed = frozen.parsed;\n    usage.unfreeze();\n    validation.unfreeze();\n    command.unfreeze();\n    strict = frozen.strict;\n    completionCommand = frozen.completionCommand;\n    parseFn = null;\n    parseContext = null;\n    frozen = undefined;\n  }\n\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('requiresArg', keys);\n    return self;\n  };\n\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n\n  function populateParserHintArray(type, keys, value) {\n    keys = [].concat(keys);\n    keys.forEach(function (key) {\n      options[type].push(key);\n    });\n  }\n\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintObject(self.nargs, false, 'narg', key, value);\n    return self;\n  };\n\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.choices, true, 'choices', key, value);\n    return self;\n  };\n\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.alias, true, 'alias', key, value);\n    return self;\n  }; // TODO: actually deprecate self.defaults.\n\n\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription;\n\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value);\n      value = value.call();\n    }\n\n    populateParserHintObject(self.default, false, 'default', key, value);\n    return self;\n  };\n\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    populateParserHintObject(self.describe, false, 'key', key, true);\n    usage.describe(key, desc);\n    return self;\n  };\n\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg);\n    return self;\n  };\n\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value);\n    return self;\n  };\n\n  function populateParserHintObject(builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      var temp = {};\n      key.forEach(function (k) {\n        temp[k] = value;\n      });\n      builder(temp);\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach(function (k) {\n        builder(k, key[k]);\n      });\n    } else {\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value);\n      } else {\n        options[type][key] = value;\n      }\n    }\n  }\n\n  self.config = function (key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length); // allow a config object to be provided directly.\n\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    } // allow for a custom parsing function.\n\n\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = null;\n    }\n\n    key = key || 'config';\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(function (k) {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length);\n    usage.example(cmd, description);\n    return self;\n  };\n\n  self.command = function (cmd, description, builder, handler) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function]', [cmd, description, builder, handler], arguments.length);\n    command.addHandler(cmd, description, builder, handler);\n    return self;\n  };\n\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length);\n    const req = parentRequire || require;\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n    return self;\n  }; // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n\n\n  self.demand = self.required = self.require = function (keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(function (key) {\n        self.demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        self.demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys);\n      }\n    }\n\n    return self;\n  };\n\n  self.demandCommand = function (min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null] [string|null]', [min, max, minMsg, maxMsg], arguments.length);\n    if (typeof min === 'undefined') min = 1;\n\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min: min,\n      max: max,\n      minMsg: minMsg,\n      maxMsg: maxMsg\n    };\n    return self;\n  };\n\n  self.getDemandedOptions = function () {\n    argsert([], 0);\n    return options.demandedOptions;\n  };\n\n  self.getDemandedCommands = function () {\n    argsert([], 0);\n    return options.demandedCommands;\n  };\n\n  self.implies = function (key, value) {\n    argsert('<string|object> [string]', [key, value], arguments.length);\n    validation.implies(key, value);\n    return self;\n  };\n\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string]', [key1, key2], arguments.length);\n    validation.conflicts(key1, key2);\n    return self;\n  };\n\n  self.usage = function (msg, opts) {\n    argsert('<string|null|object> [object]', [msg, opts], arguments.length);\n\n    if (!opts && typeof msg === 'object') {\n      opts = msg;\n      msg = null;\n    }\n\n    usage.usage(msg);\n    if (opts) self.options(opts);\n    return self;\n  };\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length);\n    usage.epilog(msg);\n    return self;\n  };\n\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length);\n    usage.failFn(f);\n    return self;\n  };\n\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation.check(f, _global !== false);\n    return self;\n  };\n\n  self.global = function (globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n\n    if (global !== false) {\n      options.local = options.local.filter(function (l) {\n        return globals.indexOf(l) === -1;\n      });\n    } else {\n      globals.forEach(function (g) {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n\n    return self;\n  };\n\n  self.pkgConf = function (key, path) {\n    argsert('<string> [string]', [key, path], arguments.length);\n    var conf = null; // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n\n    var obj = pkgUp(path || cwd); // If an object exists in the key, add it to options.configObjects\n\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], path || cwd);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n\n    return self;\n  };\n\n  var pkgs = {};\n\n  function pkgUp(path) {\n    var npath = path || '*';\n    if (pkgs[npath]) return pkgs[npath];\n\n    const readPkgUp = require('read-pkg-up');\n\n    var obj = {};\n\n    try {\n      obj = readPkgUp.sync({\n        cwd: path || require('require-main-filename')(parentRequire || require),\n        normalize: false\n      });\n    } catch (noop) {}\n\n    pkgs[npath] = obj.pkg || {};\n    return pkgs[npath];\n  }\n\n  var parseFn = null;\n  var parseContext = null;\n\n  self.parse = function (args, shortCircuit, _parseFn) {\n    argsert('<string|array> [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length); // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    } // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n\n\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = null;\n    } // completion short-circuits the parsing process,\n    // skipping validation, etc.\n\n\n    if (!shortCircuit) processArgs = args;\n    freeze();\n    if (parseFn) exitProcess = false;\n\n    var parsed = self._parseArgs(args, shortCircuit);\n\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n\n  self._getParseContext = function () {\n    return parseContext || {};\n  };\n\n  self._hasParseCallback = function () {\n    return !!parseFn;\n  };\n\n  self.option = self.options = function (key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n\n      options.key[key] = true; // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias);\n      var demand = opt.demand || opt.required || opt.require; // deprecated, use 'demandOption' instead\n\n      if (demand) {\n        self.demand(key, demand);\n      }\n\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n\n      if ('config' in opt) {\n        self.config(key, opt.configParser);\n      }\n\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts);\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n\n      if ('implies' in opt) {\n        self.implies(key, opt.implies);\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs);\n      }\n\n      if ('normalize' in opt) {\n        self.normalize(key);\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices);\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce);\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group);\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n\n      var desc = opt.describe || opt.description || opt.desc;\n\n      if (desc) {\n        self.describe(key, desc);\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n\n    return self;\n  };\n\n  self.getOptions = function () {\n    return options;\n  };\n\n  self.group = function (opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    var existing = preservedGroups[groupName] || groups[groupName];\n\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName];\n    }\n\n    var seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(function (key) {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  };\n\n  self.getGroups = function () {\n    // combine explicit and preserved groups. explicit groups should be first\n    return assign(groups, preservedGroups);\n  }; // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n\n\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) options.envPrefix = undefined;else options.envPrefix = prefix || '';\n    return self;\n  };\n\n  self.wrap = function (cols) {\n    argsert('<number|null>', [cols], arguments.length);\n    usage.wrap(cols);\n    return self;\n  };\n\n  var strict = false;\n\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n\n  self.getStrict = function () {\n    return strict;\n  };\n\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs); // run parser, if it has not already been executed.\n\n    usage.showHelp(level);\n    return self;\n  };\n\n  var versionOpt = null;\n\n  self.version = function (opt, msg, ver) {\n    argsert('[string|function] [string|function] [string]', [opt, msg, ver], arguments.length);\n\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = 'version';\n    } else if (arguments.length === 1) {\n      ver = opt;\n      opt = 'version';\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = null;\n    }\n\n    versionOpt = opt;\n    msg = msg || usage.deferY18nLookup('Show version number');\n    usage.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n\n  function guessVersion() {\n    var obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n\n  var helpOpt = null;\n  var useHelpOptAsCommand = false; // a call to .help() will enable this\n\n  self.addHelpOpt = self.help = function (opt, msg, addImplicitCmd) {\n    argsert('[string|boolean] [string|boolean] [boolean]', [opt, msg, addImplicitCmd], arguments.length); // argument shuffle\n\n    if (arguments.length === 0) {\n      useHelpOptAsCommand = true;\n    } else if (arguments.length === 1) {\n      if (typeof opt === 'boolean') {\n        useHelpOptAsCommand = opt;\n        opt = null;\n      } else {\n        useHelpOptAsCommand = true;\n      }\n    } else if (arguments.length === 2) {\n      if (typeof msg === 'boolean') {\n        useHelpOptAsCommand = msg;\n        msg = null;\n      } else {\n        useHelpOptAsCommand = true;\n      }\n    } else {\n      useHelpOptAsCommand = Boolean(addImplicitCmd);\n    } // use arguments, fallback to defaults for opt and msg\n\n\n    helpOpt = opt || 'help';\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n    return self;\n  };\n\n  self.showHelpOnFail = function (enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage.showHelpOnFail(enabled, message);\n    return self;\n  };\n\n  var exitProcess = true;\n\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n\n    if (typeof enabled !== 'boolean') {\n      enabled = true;\n    }\n\n    exitProcess = enabled;\n    return self;\n  };\n\n  self.getExitProcess = function () {\n    return exitProcess;\n  };\n\n  var completionCommand = null;\n\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length); // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = null;\n    } // register the completion command.\n\n\n    completionCommand = cmd || 'completion';\n\n    if (!desc && desc !== false) {\n      desc = 'generate bash completion script';\n    }\n\n    self.command(completionCommand, desc); // a function can be provided\n\n    if (fn) completion.registerFunction(fn);\n    return self;\n  };\n\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length);\n    $0 = $0 || self.$0;\n\n    _logger.log(completion.generateCompletionScript($0));\n\n    return self;\n  };\n\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length);\n    completion.getCompletion(args, done);\n  };\n\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length);\n\n    if (arguments.length === 0) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n\n  var detectLocale = true;\n\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n\n  self.getDetectLocale = function () {\n    return detectLocale;\n  };\n\n  var hasOutput = false;\n  var exitError = null; // maybe exit, always capture\n  // context about why we wanted to exit.\n\n  self.exit = function (code, err) {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) process.exit(code);\n  }; // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n\n\n  var _logger = {\n    log: function () {\n      const args = [];\n\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n\n      if (!self._hasParseCallback()) console.log.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n    error: function () {\n      const args = [];\n\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n\n      if (!self._hasParseCallback()) console.error.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n  };\n\n  self._getLoggerInstance = function () {\n    return _logger;\n  }; // has yargs output an error our help\n  // message in the current execution context.\n\n\n  self._hasOutput = function () {\n    return hasOutput;\n  };\n\n  self._setHasOutput = function () {\n    hasOutput = true;\n  };\n\n  var recommendCommands;\n\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true;\n    return self;\n  };\n\n  self.getUsageInstance = function () {\n    return usage;\n  };\n\n  self.getValidationInstance = function () {\n    return validation;\n  };\n\n  self.getCommandInstance = function () {\n    return command;\n  };\n\n  self.terminalWidth = function () {\n    argsert([], 0);\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n  };\n\n  Object.defineProperty(self, 'argv', {\n    get: function () {\n      return self._parseArgs(processArgs);\n    },\n    enumerable: true\n  });\n\n  self._parseArgs = function (args, shortCircuit, _skipValidation, commandIndex) {\n    var skipValidation = !!_skipValidation;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = pkgUp()['yargs'] || {};\n    const parsed = Parser.detailed(args, options);\n    var argv = parsed.argv;\n    if (parseContext) argv = assign(argv, parseContext);\n    var aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n\n    try {\n      guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n\n      if (shortCircuit) {\n        return argv;\n      }\n\n      if (argv._.length) {\n        // check for helpOpt in argv._ before running commands\n        // assumes helpOpt must be valid if useHelpOptAsCommand is true\n        if (useHelpOptAsCommand) {\n          // consider any multi-char helpOpt alias as a valid help command\n          // unless all helpOpt aliases are single-char\n          // note that parsed.aliases is a normalized bidirectional map :)\n          var helpCmds = [helpOpt].concat(aliases[helpOpt] || []);\n          var multiCharHelpCmds = helpCmds.filter(function (k) {\n            return k.length > 1;\n          });\n          if (multiCharHelpCmds.length) helpCmds = multiCharHelpCmds; // look for and strip any helpCmds from argv._\n\n          argv._ = argv._.filter(function (cmd) {\n            if (~helpCmds.indexOf(cmd)) {\n              argv[helpOpt] = true;\n              return false;\n            }\n\n            return true;\n          });\n        } // if there's a handler associated with a\n        // command defer processing to it.\n\n\n        var handlerKeys = command.getCommands();\n\n        if (handlerKeys.length) {\n          var firstUnknownCommand;\n\n          for (var i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              setPlaceholderKeys(argv); // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n\n              return command.runCommand(cmd, self, parsed, i + 1);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          } // run the default command, if defined\n\n\n          if (command.hasDefaultCommand() && !argv[helpOpt]) {\n            setPlaceholderKeys(argv);\n            return command.runCommand(null, self, parsed);\n          } // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n\n\n          if (recommendCommands && firstUnknownCommand && !argv[helpOpt]) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        } // generate a completion script for adding to ~/.bashrc.\n\n\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command.hasDefaultCommand() && !argv[helpOpt]) {\n        setPlaceholderKeys(argv);\n        return command.runCommand(null, self, parsed);\n      } // we must run completions first, a user might\n      // want to complete the --help or --version option.\n\n\n      if (completion.completionKey in argv) {\n        if (exitProcess) setBlocking(true); // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n\n        var completionArgs = args.slice(args.indexOf('--' + completion.completionKey) + 1);\n        completion.getCompletion(completionArgs, function (completions) {\n          ;\n          (completions || []).forEach(function (completion) {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return setPlaceholderKeys(argv);\n      } // Handle 'help' and 'version' options\n      // if we haven't already output help!\n\n\n      if (!hasOutput) {\n        Object.keys(argv).forEach(function (key) {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage.showVersion();\n            self.exit(0);\n          }\n        });\n      } // Check if any of the options to skip validation were provided\n\n\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(function (key) {\n          return options.skipValidation.indexOf(key) >= 0 && argv[key] === true;\n        });\n      } // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n\n\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message); // if we're executed via bash completion, don't\n        // bother with validation.\n\n        if (!argv[completion.completionKey]) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err);else throw err;\n    }\n\n    return setPlaceholderKeys(argv);\n  };\n\n  self._runValidation = function (argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message);\n    validation.nonOptionCount(argv);\n    validation.missingArgumentValue(argv);\n    validation.requiredArguments(argv);\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap);\n    validation.customChecks(argv, aliases);\n    validation.limitedChoices(argv);\n    validation.implications(argv);\n    validation.conflicting(argv);\n  };\n\n  function guessLocale() {\n    if (!detectLocale) return;\n\n    try {\n      const osLocale = require('os-locale');\n\n      self.locale(osLocale.sync({\n        spawn: false\n      }));\n    } catch (err) {// if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n\n  function setPlaceholderKeys(argv) {\n    Object.keys(options.key).forEach(function (key) {\n      // don't set placeholder keys for dot\n      // notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  return self;\n} // rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\n\n\nexports.rebase = rebase;\n\nfunction rebase(base, dir) {\n  return path.relative(base, dir);\n}","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/yargs/yargs.js"],"names":["argsert","require","assign","Command","Completion","Parser","path","Usage","Validation","Y18n","objFilter","setBlocking","applyExtends","YError","exports","module","Yargs","processArgs","cwd","parentRequire","self","command","completion","groups","output","preservedGroups","usage","validation","y18n","directory","resolve","__dirname","updateFiles","process","$0","argv","slice","map","x","i","test","b","rebase","match","length","join","trim","env","_","undefined","replace","dirname","execPath","context","resets","commands","files","getContext","options","resetOptions","reset","aliases","tmpOptions","local","configObjects","localLookup","forEach","l","a","Object","keys","reduce","acc","groupName","filter","key","arrayOptions","objectOptions","k","v","envPrefix","completionCommand","exitError","hasOutput","parsed","frozen","freeze","exitProcess","strict","unfreeze","parseFn","parseContext","boolean","arguments","populateParserHintArray","array","number","normalize","count","string","requiresArg","skipValidation","type","value","concat","push","nargs","populateParserHintObject","choices","alias","default","defaults","defaultDescription","functionDescription","call","describe","desc","demandOption","msg","coerce","builder","isArray","Array","temp","config","deferY18nLookup","example","cmd","description","handler","addHandler","commandDir","dir","opts","req","addDirectory","demand","required","max","Infinity","demandCommand","min","minMsg","maxMsg","global","demandedCommands","getDemandedOptions","demandedOptions","getDemandedCommands","implies","conflicts","key1","key2","epilogue","epilog","fail","f","failFn","check","_global","globals","indexOf","g","pkgConf","conf","obj","pkgUp","pkgs","npath","readPkgUp","sync","noop","pkg","parse","args","shortCircuit","_parseFn","_parseArgs","_getParseContext","_hasParseCallback","option","opt","configParser","group","getOptions","existing","seen","getGroups","prefix","wrap","cols","enabled","getStrict","showHelp","level","versionOpt","version","ver","guessVersion","helpOpt","useHelpOptAsCommand","addHelpOpt","help","addImplicitCmd","Boolean","showHelpOnFail","message","getExitProcess","fn","registerFunction","showCompletionScript","_logger","log","generateCompletionScript","getCompletion","done","locale","guessLocale","getLocale","detectLocale","setLocale","updateStrings","updateLocale","detect","getDetectLocale","exit","code","err","console","apply","error","_getLoggerInstance","_hasOutput","_setHasOutput","recommendCommands","recommend","getUsageInstance","getValidationInstance","getCommandInstance","terminalWidth","stdout","columns","defineProperty","get","enumerable","_skipValidation","commandIndex","__","configuration","detailed","helpCmds","multiCharHelpCmds","handlerKeys","getCommands","firstUnknownCommand","String","setPlaceholderKeys","runCommand","hasDefaultCommand","completionKey","completionArgs","completions","showVersion","some","_runValidation","positionalMap","parseErrors","nonOptionCount","missingArgumentValue","requiredArguments","unknownArguments","customChecks","limitedChoices","implications","conflicting","osLocale","spawn","base","relative"],"mappings":"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","sourcesContent":["const argsert = require('./lib/argsert')\nconst assign = require('./lib/assign')\nconst Command = require('./lib/command')\nconst Completion = require('./lib/completion')\nconst Parser = require('yargs-parser')\nconst path = require('path')\nconst Usage = require('./lib/usage')\nconst Validation = require('./lib/validation')\nconst Y18n = require('y18n')\nconst objFilter = require('./lib/obj-filter')\nconst setBlocking = require('set-blocking')\nconst applyExtends = require('./lib/apply-extends')\nconst YError = require('./lib/yerror')\n\nvar exports = module.exports = Yargs\nfunction Yargs (processArgs, cwd, parentRequire) {\n  processArgs = processArgs || [] // handle calling yargs().\n\n  const self = {}\n  var command = null\n  var completion = null\n  var groups = {}\n  var output = ''\n  var preservedGroups = {}\n  var usage = null\n  var validation = null\n\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  })\n\n  if (!cwd) cwd = process.cwd()\n\n  self.$0 = process.argv\n    .slice(0, 2)\n    .map(function (x, i) {\n      // ignore the node bin, specify this in your\n      // bin file with #!/usr/bin/env node\n      if (i === 0 && /\\b(node|iojs)(\\.exe)?$/.test(x)) return\n      var b = rebase(cwd, x)\n      return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x\n    })\n    .join(' ').trim()\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\n      path.dirname(process.execPath) + '/', ''\n    )\n  }\n\n  // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n  const context = { resets: -1, commands: [], files: [] }\n  self.getContext = function () {\n    return context\n  }\n\n  // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n  var options\n  self.resetOptions = self.reset = function (aliases) {\n    context.resets++\n    aliases = aliases || {}\n    options = options || {}\n    // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n    var tmpOptions = {}\n    tmpOptions.local = options.local ? options.local : []\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []\n\n    // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n    var localLookup = {}\n    tmpOptions.local.forEach(function (l) {\n      localLookup[l] = true\n      ;(aliases[l] || []).forEach(function (a) {\n        localLookup[a] = true\n      })\n    })\n\n    // preserve all groups not set to local.\n    preservedGroups = Object.keys(groups).reduce(function (acc, groupName) {\n      var keys = groups[groupName].filter(function (key) {\n        return !(key in localLookup)\n      })\n      if (keys.length > 0) {\n        acc[groupName] = keys\n      }\n      return acc\n    }, {})\n    // groups can now be reset\n    groups = {}\n\n    var arrayOptions = [\n      'array', 'boolean', 'string', 'requiresArg', 'skipValidation',\n      'count', 'normalize', 'number'\n    ]\n\n    var objectOptions = [\n      'narg', 'key', 'alias', 'default', 'defaultDescription',\n      'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'\n    ]\n\n    arrayOptions.forEach(function (k) {\n      tmpOptions[k] = (options[k] || []).filter(function (k) {\n        return !localLookup[k]\n      })\n    })\n\n    objectOptions.forEach(function (k) {\n      tmpOptions[k] = objFilter(options[k], function (k, v) {\n        return !localLookup[k]\n      })\n    })\n\n    tmpOptions.envPrefix = options.envPrefix\n    options = tmpOptions\n\n    // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n)\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n)\n    command = command ? command.reset() : Command(self, usage, validation)\n    if (!completion) completion = Completion(self, usage, command)\n\n    completionCommand = null\n    output = ''\n    exitError = null\n    hasOutput = false\n    self.parsed = false\n\n    return self\n  }\n  self.resetOptions()\n\n  // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n  var frozen\n  function freeze () {\n    frozen = {}\n    frozen.options = options\n    frozen.configObjects = options.configObjects.slice(0)\n    frozen.exitProcess = exitProcess\n    frozen.groups = groups\n    usage.freeze()\n    validation.freeze()\n    command.freeze()\n    frozen.strict = strict\n    frozen.completionCommand = completionCommand\n    frozen.output = output\n    frozen.exitError = exitError\n    frozen.hasOutput = hasOutput\n    frozen.parsed = self.parsed\n  }\n  function unfreeze () {\n    options = frozen.options\n    options.configObjects = frozen.configObjects\n    exitProcess = frozen.exitProcess\n    groups = frozen.groups\n    output = frozen.output\n    exitError = frozen.exitError\n    hasOutput = frozen.hasOutput\n    self.parsed = frozen.parsed\n    usage.unfreeze()\n    validation.unfreeze()\n    command.unfreeze()\n    strict = frozen.strict\n    completionCommand = frozen.completionCommand\n    parseFn = null\n    parseContext = null\n    frozen = undefined\n  }\n\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('boolean', keys)\n    return self\n  }\n\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('array', keys)\n    return self\n  }\n\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('number', keys)\n    return self\n  }\n\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('normalize', keys)\n    return self\n  }\n\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('count', keys)\n    return self\n  }\n\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('string', keys)\n    return self\n  }\n\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('requiresArg', keys)\n    return self\n  }\n\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('skipValidation', keys)\n    return self\n  }\n\n  function populateParserHintArray (type, keys, value) {\n    keys = [].concat(keys)\n    keys.forEach(function (key) {\n      options[type].push(key)\n    })\n  }\n\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length)\n    populateParserHintObject(self.nargs, false, 'narg', key, value)\n    return self\n  }\n\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.choices, true, 'choices', key, value)\n    return self\n  }\n\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.alias, true, 'alias', key, value)\n    return self\n  }\n\n  // TODO: actually deprecate self.defaults.\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length)\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)\n      value = value.call()\n    }\n    populateParserHintObject(self.default, false, 'default', key, value)\n    return self\n  }\n\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length)\n    populateParserHintObject(self.describe, false, 'key', key, true)\n    usage.describe(key, desc)\n    return self\n  }\n\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length)\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg)\n    return self\n  }\n\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length)\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value)\n    return self\n  }\n\n  function populateParserHintObject (builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      var temp = {}\n      key.forEach(function (k) {\n        temp[k] = value\n      })\n      builder(temp)\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach(function (k) {\n        builder(k, key[k])\n      })\n    } else {\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value)\n      } else {\n        options[type][key] = value\n      }\n    }\n  }\n\n  self.config = function (key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length)\n    // allow a config object to be provided directly.\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd)\n      options.configObjects = (options.configObjects || []).concat(key)\n      return self\n    }\n\n    // allow for a custom parsing function.\n    if (typeof msg === 'function') {\n      parseFn = msg\n      msg = null\n    }\n\n    key = key || 'config'\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))\n    ;(Array.isArray(key) ? key : [key]).forEach(function (k) {\n      options.config[k] = parseFn || true\n    })\n\n    return self\n  }\n\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length)\n    usage.example(cmd, description)\n    return self\n  }\n\n  self.command = function (cmd, description, builder, handler) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function]', [cmd, description, builder, handler], arguments.length)\n    command.addHandler(cmd, description, builder, handler)\n    return self\n  }\n\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length)\n    const req = parentRequire || require\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts)\n    return self\n  }\n\n  // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n  self.demand = self.required = self.require = function (keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(function (key) {\n        self.demandOption(key, msg)\n      })\n      max = Infinity\n    } else if (typeof max !== 'number') {\n      msg = max\n      max = Infinity\n    }\n\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg)\n    } else if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        self.demandOption(key, msg)\n      })\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg)\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys)\n      }\n    }\n\n    return self\n  }\n\n  self.demandCommand = function (min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null] [string|null]', [min, max, minMsg, maxMsg], arguments.length)\n\n    if (typeof min === 'undefined') min = 1\n\n    if (typeof max !== 'number') {\n      minMsg = max\n      max = Infinity\n    }\n\n    self.global('_', false)\n\n    options.demandedCommands._ = {\n      min: min,\n      max: max,\n      minMsg: minMsg,\n      maxMsg: maxMsg\n    }\n\n    return self\n  }\n\n  self.getDemandedOptions = function () {\n    argsert([], 0)\n    return options.demandedOptions\n  }\n\n  self.getDemandedCommands = function () {\n    argsert([], 0)\n    return options.demandedCommands\n  }\n\n  self.implies = function (key, value) {\n    argsert('<string|object> [string]', [key, value], arguments.length)\n    validation.implies(key, value)\n    return self\n  }\n\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string]', [key1, key2], arguments.length)\n    validation.conflicts(key1, key2)\n    return self\n  }\n\n  self.usage = function (msg, opts) {\n    argsert('<string|null|object> [object]', [msg, opts], arguments.length)\n\n    if (!opts && typeof msg === 'object') {\n      opts = msg\n      msg = null\n    }\n\n    usage.usage(msg)\n\n    if (opts) self.options(opts)\n\n    return self\n  }\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length)\n    usage.epilog(msg)\n    return self\n  }\n\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length)\n    usage.failFn(f)\n    return self\n  }\n\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length)\n    validation.check(f, _global !== false)\n    return self\n  }\n\n  self.global = function (globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length)\n    globals = [].concat(globals)\n    if (global !== false) {\n      options.local = options.local.filter(function (l) {\n        return globals.indexOf(l) === -1\n      })\n    } else {\n      globals.forEach(function (g) {\n        if (options.local.indexOf(g) === -1) options.local.push(g)\n      })\n    }\n    return self\n  }\n\n  self.pkgConf = function (key, path) {\n    argsert('<string> [string]', [key, path], arguments.length)\n    var conf = null\n    // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n    var obj = pkgUp(path || cwd)\n\n    // If an object exists in the key, add it to options.configObjects\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], path || cwd)\n      options.configObjects = (options.configObjects || []).concat(conf)\n    }\n\n    return self\n  }\n\n  var pkgs = {}\n  function pkgUp (path) {\n    var npath = path || '*'\n    if (pkgs[npath]) return pkgs[npath]\n    const readPkgUp = require('read-pkg-up')\n\n    var obj = {}\n    try {\n      obj = readPkgUp.sync({\n        cwd: path || require('require-main-filename')(parentRequire || require),\n        normalize: false\n      })\n    } catch (noop) {}\n\n    pkgs[npath] = obj.pkg || {}\n    return pkgs[npath]\n  }\n\n  var parseFn = null\n  var parseContext = null\n  self.parse = function (args, shortCircuit, _parseFn) {\n    argsert('<string|array> [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length)\n\n    // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit\n      shortCircuit = _parseFn\n    }\n\n    // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit\n      shortCircuit = null\n    }\n    // completion short-circuits the parsing process,\n    // skipping validation, etc.\n    if (!shortCircuit) processArgs = args\n\n    freeze()\n    if (parseFn) exitProcess = false\n\n    var parsed = self._parseArgs(args, shortCircuit)\n    if (parseFn) parseFn(exitError, parsed, output)\n    unfreeze()\n\n    return parsed\n  }\n\n  self._getParseContext = function () {\n    return parseContext || {}\n  }\n\n  self._hasParseCallback = function () {\n    return !!parseFn\n  }\n\n  self.option = self.options = function (key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length)\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.options(k, key[k])\n      })\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {}\n      }\n\n      options.key[key] = true // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias)\n\n      var demand = opt.demand || opt.required || opt.require\n\n      // deprecated, use 'demandOption' instead\n      if (demand) {\n        self.demand(key, demand)\n      }\n\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined)\n      }\n\n      if ('config' in opt) {\n        self.config(key, opt.configParser)\n      }\n\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts)\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default)\n      }\n\n      if ('implies' in opt) {\n        self.implies(key, opt.implies)\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs)\n      }\n\n      if ('normalize' in opt) {\n        self.normalize(key)\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices)\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce)\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group)\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key)\n        if (opt.alias) self.boolean(opt.alias)\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key)\n        if (opt.alias) self.array(opt.alias)\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key)\n        if (opt.alias) self.number(opt.alias)\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key)\n        if (opt.alias) self.string(opt.alias)\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key)\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global)\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key)\n      }\n\n      var desc = opt.describe || opt.description || opt.desc\n      if (desc) {\n        self.describe(key, desc)\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key)\n      }\n    }\n\n    return self\n  }\n  self.getOptions = function () {\n    return options\n  }\n\n  self.group = function (opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length)\n    var existing = preservedGroups[groupName] || groups[groupName]\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName]\n    }\n\n    var seen = {}\n    groups[groupName] = (existing || []).concat(opts).filter(function (key) {\n      if (seen[key]) return false\n      return (seen[key] = true)\n    })\n    return self\n  }\n  self.getGroups = function () {\n    // combine explicit and preserved groups. explicit groups should be first\n    return assign(groups, preservedGroups)\n  }\n\n  // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length)\n    if (prefix === false) options.envPrefix = undefined\n    else options.envPrefix = prefix || ''\n    return self\n  }\n\n  self.wrap = function (cols) {\n    argsert('<number|null>', [cols], arguments.length)\n    usage.wrap(cols)\n    return self\n  }\n\n  var strict = false\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length)\n    strict = enabled !== false\n    return self\n  }\n  self.getStrict = function () {\n    return strict\n  }\n\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length)\n    if (!self.parsed) self._parseArgs(processArgs) // run parser, if it has not already been executed.\n    usage.showHelp(level)\n    return self\n  }\n\n  var versionOpt = null\n  self.version = function (opt, msg, ver) {\n    argsert('[string|function] [string|function] [string]', [opt, msg, ver], arguments.length)\n    if (arguments.length === 0) {\n      ver = guessVersion()\n      opt = 'version'\n    } else if (arguments.length === 1) {\n      ver = opt\n      opt = 'version'\n    } else if (arguments.length === 2) {\n      ver = msg\n      msg = null\n    }\n\n    versionOpt = opt\n    msg = msg || usage.deferY18nLookup('Show version number')\n\n    usage.version(ver || undefined)\n    self.boolean(versionOpt)\n    self.describe(versionOpt, msg)\n    return self\n  }\n\n  function guessVersion () {\n    var obj = pkgUp()\n\n    return obj.version || 'unknown'\n  }\n\n  var helpOpt = null\n  var useHelpOptAsCommand = false // a call to .help() will enable this\n  self.addHelpOpt = self.help = function (opt, msg, addImplicitCmd) {\n    argsert('[string|boolean] [string|boolean] [boolean]', [opt, msg, addImplicitCmd], arguments.length)\n\n    // argument shuffle\n    if (arguments.length === 0) {\n      useHelpOptAsCommand = true\n    } else if (arguments.length === 1) {\n      if (typeof opt === 'boolean') {\n        useHelpOptAsCommand = opt\n        opt = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else if (arguments.length === 2) {\n      if (typeof msg === 'boolean') {\n        useHelpOptAsCommand = msg\n        msg = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else {\n      useHelpOptAsCommand = Boolean(addImplicitCmd)\n    }\n    // use arguments, fallback to defaults for opt and msg\n    helpOpt = opt || 'help'\n    self.boolean(helpOpt)\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'))\n    return self\n  }\n\n  self.showHelpOnFail = function (enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length)\n    usage.showHelpOnFail(enabled, message)\n    return self\n  }\n\n  var exitProcess = true\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length)\n    if (typeof enabled !== 'boolean') {\n      enabled = true\n    }\n    exitProcess = enabled\n    return self\n  }\n  self.getExitProcess = function () {\n    return exitProcess\n  }\n\n  var completionCommand = null\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length)\n\n    // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n    if (typeof desc === 'function') {\n      fn = desc\n      desc = null\n    }\n\n    // register the completion command.\n    completionCommand = cmd || 'completion'\n    if (!desc && desc !== false) {\n      desc = 'generate bash completion script'\n    }\n    self.command(completionCommand, desc)\n\n    // a function can be provided\n    if (fn) completion.registerFunction(fn)\n\n    return self\n  }\n\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length)\n    $0 = $0 || self.$0\n    _logger.log(completion.generateCompletionScript($0))\n    return self\n  }\n\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length)\n    completion.getCompletion(args, done)\n  }\n\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length)\n    if (arguments.length === 0) {\n      guessLocale()\n      return y18n.getLocale()\n    }\n    detectLocale = false\n    y18n.setLocale(locale)\n    return self\n  }\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length)\n    detectLocale = false\n    y18n.updateLocale(obj)\n    return self\n  }\n\n  var detectLocale = true\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length)\n    detectLocale = detect\n    return self\n  }\n  self.getDetectLocale = function () {\n    return detectLocale\n  }\n\n  var hasOutput = false\n  var exitError = null\n  // maybe exit, always capture\n  // context about why we wanted to exit.\n  self.exit = function (code, err) {\n    hasOutput = true\n    exitError = err\n    if (exitProcess) process.exit(code)\n  }\n\n  // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n  var _logger = {\n    log: function () {\n      const args = []\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.log.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    },\n    error: function () {\n      const args = []\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.error.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    }\n  }\n  self._getLoggerInstance = function () {\n    return _logger\n  }\n  // has yargs output an error our help\n  // message in the current execution context.\n  self._hasOutput = function () {\n    return hasOutput\n  }\n\n  self._setHasOutput = function () {\n    hasOutput = true\n  }\n\n  var recommendCommands\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length)\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true\n    return self\n  }\n\n  self.getUsageInstance = function () {\n    return usage\n  }\n\n  self.getValidationInstance = function () {\n    return validation\n  }\n\n  self.getCommandInstance = function () {\n    return command\n  }\n\n  self.terminalWidth = function () {\n    argsert([], 0)\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null\n  }\n\n  Object.defineProperty(self, 'argv', {\n    get: function () {\n      return self._parseArgs(processArgs)\n    },\n    enumerable: true\n  })\n\n  self._parseArgs = function (args, shortCircuit, _skipValidation, commandIndex) {\n    var skipValidation = !!_skipValidation\n    args = args || processArgs\n\n    options.__ = y18n.__\n    options.configuration = pkgUp()['yargs'] || {}\n    const parsed = Parser.detailed(args, options)\n    var argv = parsed.argv\n    if (parseContext) argv = assign(argv, parseContext)\n    var aliases = parsed.aliases\n\n    argv.$0 = self.$0\n    self.parsed = parsed\n\n    try {\n      guessLocale() // guess locale lazily, so that it can be turned off in chain.\n\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n      if (shortCircuit) {\n        return argv\n      }\n\n      if (argv._.length) {\n        // check for helpOpt in argv._ before running commands\n        // assumes helpOpt must be valid if useHelpOptAsCommand is true\n        if (useHelpOptAsCommand) {\n          // consider any multi-char helpOpt alias as a valid help command\n          // unless all helpOpt aliases are single-char\n          // note that parsed.aliases is a normalized bidirectional map :)\n          var helpCmds = [helpOpt].concat(aliases[helpOpt] || [])\n          var multiCharHelpCmds = helpCmds.filter(function (k) {\n            return k.length > 1\n          })\n          if (multiCharHelpCmds.length) helpCmds = multiCharHelpCmds\n          // look for and strip any helpCmds from argv._\n          argv._ = argv._.filter(function (cmd) {\n            if (~helpCmds.indexOf(cmd)) {\n              argv[helpOpt] = true\n              return false\n            }\n            return true\n          })\n        }\n\n        // if there's a handler associated with a\n        // command defer processing to it.\n        var handlerKeys = command.getCommands()\n        if (handlerKeys.length) {\n          var firstUnknownCommand\n          for (var i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i])\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              setPlaceholderKeys(argv)\n              // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n              return command.runCommand(cmd, self, parsed, i + 1)\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd\n              break\n            }\n          }\n\n          // run the default command, if defined\n          if (command.hasDefaultCommand() && !argv[helpOpt]) {\n            setPlaceholderKeys(argv)\n            return command.runCommand(null, self, parsed)\n          }\n\n          // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n          if (recommendCommands && firstUnknownCommand && !argv[helpOpt]) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys)\n          }\n        }\n\n        // generate a completion script for adding to ~/.bashrc.\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {\n          if (exitProcess) setBlocking(true)\n          self.showCompletionScript()\n          self.exit(0)\n        }\n      } else if (command.hasDefaultCommand() && !argv[helpOpt]) {\n        setPlaceholderKeys(argv)\n        return command.runCommand(null, self, parsed)\n      }\n\n      // we must run completions first, a user might\n      // want to complete the --help or --version option.\n      if (completion.completionKey in argv) {\n        if (exitProcess) setBlocking(true)\n\n        // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n        var completionArgs = args.slice(args.indexOf('--' + completion.completionKey) + 1)\n        completion.getCompletion(completionArgs, function (completions) {\n          ;(completions || []).forEach(function (completion) {\n            _logger.log(completion)\n          })\n\n          self.exit(0)\n        })\n        return setPlaceholderKeys(argv)\n      }\n\n      // Handle 'help' and 'version' options\n      // if we haven't already output help!\n      if (!hasOutput) {\n        Object.keys(argv).forEach(function (key) {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true)\n\n            skipValidation = true\n            self.showHelp('log')\n            self.exit(0)\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true)\n\n            skipValidation = true\n            usage.showVersion()\n            self.exit(0)\n          }\n        })\n      }\n\n      // Check if any of the options to skip validation were provided\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(function (key) {\n          return options.skipValidation.indexOf(key) >= 0 && argv[key] === true\n        })\n      }\n\n      // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message)\n\n        // if we're executed via bash completion, don't\n        // bother with validation.\n        if (!argv[completion.completionKey]) {\n          self._runValidation(argv, aliases, {}, parsed.error)\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err)\n      else throw err\n    }\n\n    return setPlaceholderKeys(argv)\n  }\n\n  self._runValidation = function (argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message)\n    validation.nonOptionCount(argv)\n    validation.missingArgumentValue(argv)\n    validation.requiredArguments(argv)\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap)\n    validation.customChecks(argv, aliases)\n    validation.limitedChoices(argv)\n    validation.implications(argv)\n    validation.conflicting(argv)\n  }\n\n  function guessLocale () {\n    if (!detectLocale) return\n\n    try {\n      const osLocale = require('os-locale')\n      self.locale(osLocale.sync({ spawn: false }))\n    } catch (err) {\n      // if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n\n  function setPlaceholderKeys (argv) {\n    Object.keys(options.key).forEach(function (key) {\n      // don't set placeholder keys for dot\n      // notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  return self\n}\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase\nfunction rebase (base, dir) {\n  return path.relative(base, dir)\n}\n"]},"metadata":{},"sourceType":"script"}