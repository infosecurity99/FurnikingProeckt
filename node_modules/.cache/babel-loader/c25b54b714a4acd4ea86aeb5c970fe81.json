{"ast":null,"code":"'use strict';\n\nvar Promise = require('pinkie-promise');\n\nvar objectAssign = require('object-assign');\n\nvar bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n  if (!inputStream) {\n    return Promise.reject(new Error('Expected a stream'));\n  }\n\n  opts = objectAssign({\n    maxBuffer: Infinity\n  }, opts);\n  var maxBuffer = opts.maxBuffer;\n  var stream;\n  var clean;\n  var p = new Promise(function (resolve, reject) {\n    stream = bufferStream(opts);\n    inputStream.once('error', error);\n    inputStream.pipe(stream);\n    stream.on('data', function () {\n      if (stream.getBufferedLength() > maxBuffer) {\n        reject(new Error('maxBuffer exceeded'));\n      }\n    });\n    stream.once('error', error);\n    stream.on('end', resolve);\n\n    clean = function () {\n      // some streams doesn't implement the stream.Readable interface correctly\n      if (inputStream.unpipe) {\n        inputStream.unpipe(stream);\n      }\n    };\n\n    function error(err) {\n      if (err) {\n        // null check\n        err.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(err);\n    }\n  });\n  p.then(clean, clean);\n  return p.then(function () {\n    return stream.getBufferedValue();\n  });\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = function (stream, opts) {\n  return getStream(stream, objectAssign({}, opts, {\n    encoding: 'buffer'\n  }));\n};\n\nmodule.exports.array = function (stream, opts) {\n  return getStream(stream, objectAssign({}, opts, {\n    array: true\n  }));\n};","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/get-stream/index.js"],"names":["Promise","require","objectAssign","bufferStream","getStream","inputStream","opts","reject","Error","maxBuffer","Infinity","stream","clean","p","resolve","once","error","pipe","on","getBufferedLength","unpipe","err","bufferedData","getBufferedValue","then","module","exports","buffer","encoding","array"],"mappings":"AAAA;;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA1B;;AAEA,SAASG,SAAT,CAAmBC,WAAnB,EAAgCC,IAAhC,EAAsC;AACrC,MAAI,CAACD,WAAL,EAAkB;AACjB,WAAOL,OAAO,CAACO,MAAR,CAAe,IAAIC,KAAJ,CAAU,mBAAV,CAAf,CAAP;AACA;;AAEDF,EAAAA,IAAI,GAAGJ,YAAY,CAAC;AAACO,IAAAA,SAAS,EAAEC;AAAZ,GAAD,EAAwBJ,IAAxB,CAAnB;AACA,MAAIG,SAAS,GAAGH,IAAI,CAACG,SAArB;AACA,MAAIE,MAAJ;AACA,MAAIC,KAAJ;AAEA,MAAIC,CAAC,GAAG,IAAIb,OAAJ,CAAY,UAAUc,OAAV,EAAmBP,MAAnB,EAA2B;AAC9CI,IAAAA,MAAM,GAAGR,YAAY,CAACG,IAAD,CAArB;AACAD,IAAAA,WAAW,CAACU,IAAZ,CAAiB,OAAjB,EAA0BC,KAA1B;AACAX,IAAAA,WAAW,CAACY,IAAZ,CAAiBN,MAAjB;AAEAA,IAAAA,MAAM,CAACO,EAAP,CAAU,MAAV,EAAkB,YAAY;AAC7B,UAAIP,MAAM,CAACQ,iBAAP,KAA6BV,SAAjC,EAA4C;AAC3CF,QAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAU,oBAAV,CAAD,CAAN;AACA;AACD,KAJD;AAKAG,IAAAA,MAAM,CAACI,IAAP,CAAY,OAAZ,EAAqBC,KAArB;AACAL,IAAAA,MAAM,CAACO,EAAP,CAAU,KAAV,EAAiBJ,OAAjB;;AAEAF,IAAAA,KAAK,GAAG,YAAY;AACnB;AACA,UAAIP,WAAW,CAACe,MAAhB,EAAwB;AACvBf,QAAAA,WAAW,CAACe,MAAZ,CAAmBT,MAAnB;AACA;AACD,KALD;;AAOA,aAASK,KAAT,CAAeK,GAAf,EAAoB;AACnB,UAAIA,GAAJ,EAAS;AAAE;AACVA,QAAAA,GAAG,CAACC,YAAJ,GAAmBX,MAAM,CAACY,gBAAP,EAAnB;AACA;;AACDhB,MAAAA,MAAM,CAACc,GAAD,CAAN;AACA;AACD,GA1BO,CAAR;AA4BAR,EAAAA,CAAC,CAACW,IAAF,CAAOZ,KAAP,EAAcA,KAAd;AAEA,SAAOC,CAAC,CAACW,IAAF,CAAO,YAAY;AACzB,WAAOb,MAAM,CAACY,gBAAP,EAAP;AACA,GAFM,CAAP;AAGA;;AAEDE,MAAM,CAACC,OAAP,GAAiBtB,SAAjB;;AAEAqB,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,UAAUhB,MAAV,EAAkBL,IAAlB,EAAwB;AAC/C,SAAOF,SAAS,CAACO,MAAD,EAAST,YAAY,CAAC,EAAD,EAAKI,IAAL,EAAW;AAACsB,IAAAA,QAAQ,EAAE;AAAX,GAAX,CAArB,CAAhB;AACA,CAFD;;AAIAH,MAAM,CAACC,OAAP,CAAeG,KAAf,GAAuB,UAAUlB,MAAV,EAAkBL,IAAlB,EAAwB;AAC9C,SAAOF,SAAS,CAACO,MAAD,EAAST,YAAY,CAAC,EAAD,EAAKI,IAAL,EAAW;AAACuB,IAAAA,KAAK,EAAE;AAAR,GAAX,CAArB,CAAhB;AACA,CAFD","sourcesContent":["'use strict';\nvar Promise = require('pinkie-promise');\nvar objectAssign = require('object-assign');\nvar bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\topts = objectAssign({maxBuffer: Infinity}, opts);\n\tvar maxBuffer = opts.maxBuffer;\n\tvar stream;\n\tvar clean;\n\n\tvar p = new Promise(function (resolve, reject) {\n\t\tstream = bufferStream(opts);\n\t\tinputStream.once('error', error);\n\t\tinputStream.pipe(stream);\n\n\t\tstream.on('data', function () {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\treject(new Error('maxBuffer exceeded'));\n\t\t\t}\n\t\t});\n\t\tstream.once('error', error);\n\t\tstream.on('end', resolve);\n\n\t\tclean = function () {\n\t\t\t// some streams doesn't implement the stream.Readable interface correctly\n\t\t\tif (inputStream.unpipe) {\n\t\t\t\tinputStream.unpipe(stream);\n\t\t\t}\n\t\t};\n\n\t\tfunction error(err) {\n\t\t\tif (err) { // null check\n\t\t\t\terr.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\t\t\treject(err);\n\t\t}\n\t});\n\n\tp.then(clean, clean);\n\n\treturn p.then(function () {\n\t\treturn stream.getBufferedValue();\n\t});\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = function (stream, opts) {\n\treturn getStream(stream, objectAssign({}, opts, {encoding: 'buffer'}));\n};\n\nmodule.exports.array = function (stream, opts) {\n\treturn getStream(stream, objectAssign({}, opts, {array: true}));\n};\n"]},"metadata":{},"sourceType":"script"}