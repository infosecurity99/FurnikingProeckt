{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar gitHosts = require('./git-host-info.js');\n\nvar GitHost = module.exports = require('./git-host.js');\n\nvar protocolToRepresentationMap = {\n  'git+ssh': 'sshurl',\n  'git+https': 'https',\n  'ssh': 'sshurl',\n  'git': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1);\n  return protocolToRepresentationMap[protocol] || protocol;\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'));\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = decodeURIComponent(parsed.auth);\n      }\n\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3]);\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n        if (matched[1] != null) user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        if (matched[2] != null) project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      if (!(ex instanceof URIError)) throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n};\n\nfunction isGitHubShorthand(arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\n\nfunction fixupUnqualifiedGist(giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl);\n\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\n\nfunction parseGitUrl(giturl) {\n  if (typeof giturl !== 'string') giturl = '' + giturl;\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n  if (!matched) return url.parse(giturl);\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/hosted-git-info/index.js"],"names":["url","require","gitHosts","GitHost","module","exports","protocolToRepresentationMap","protocolToRepresentation","protocol","substr","slice","authProtocols","fromUrl","giturl","opts","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","RegExp","matches","Object","keys","map","gitHostName","gitHostInfo","auth","decodeURIComponent","committish","hash","user","project","defaultRepresentation","host","domain","protocols_re","test","path","pathmatch","matched","replace","ex","URIError","filter","length","arg","parse","slashes","port","hostname","search","query","pathname","href"],"mappings":"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","sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh': 'sshurl',\n  'git+https': 'https',\n  'ssh': 'sshurl',\n  'git': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1)\n  return protocolToRepresentationMap[protocol] || protocol\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = decodeURIComponent(parsed.auth)\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3])\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        if (matched[1] != null) user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        if (matched[2] != null) project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      if (!(ex instanceof URIError)) throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  if (typeof giturl !== 'string') giturl = '' + giturl\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) return url.parse(giturl)\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}