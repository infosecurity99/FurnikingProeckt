{"ast":null,"code":"'use strict';\n\nconst npa = require('npm-package-arg');\n\nconst path = require('path');\n\nconst yargs = require('yargs');\n\nconst usage = `$0 [--package|-p <package>] [--cache <path>] [--no-install] [--userconfig <path>] [-c <string>] [--shell <string>] [--shell-auto-fallback [<shell>]] [--ignore-existing] [--version|-v] [--] <command>[@version] [command-arg]...`;\nmodule.exports = parseArgs;\n\nfunction parseArgs(argv) {\n  argv = argv || process.argv;\n  const parser = yargs.usage(`Execute binaries from npm packages.\\n${usage}`).option('package', {\n    alias: 'p',\n    type: 'string',\n    describe: 'Package to be installed.'\n  }).option('cache', {\n    type: 'string',\n    describe: 'Location of the npm cache.'\n  }).option('install', {\n    type: 'boolean',\n    describe: 'Skip installation if a package is missing.',\n    default: true\n  }).option('userconfig', {\n    type: 'string',\n    describe: 'Path to user npmrc.'\n  }).option('call', {\n    alias: 'c',\n    type: 'string',\n    describe: 'Execute string as if inside `npm run-script`.'\n  }).option('shell', {\n    alias: 's',\n    type: 'string',\n    describe: 'Shell to execute the command with, if any.',\n    default: false\n  }).option('shell-auto-fallback', {\n    choices: ['', 'bash', 'fish', 'zsh'],\n    describe: 'Generate shell code to use npx as the \"command not found\" fallback.',\n    requireArg: false,\n    type: 'string'\n  }).option('ignore-existing', {\n    describe: 'Ignores existing binaries in $PATH, or in the local project. This forces npx to do a temporary install and use the latest version.',\n    type: 'boolean'\n  }).version().alias('version', 'v').help().alias('help', 'h').epilogue('For the full documentation, see the manual page for npx(1).');\n  const opts = parser.getOptions();\n  const bools = new Set(opts.boolean);\n  let cmdIndex;\n  let hasDashDash;\n\n  for (let i = 2; i < argv.length; i++) {\n    const opt = argv[i];\n\n    if (opt === '--') {\n      hasDashDash = true;\n      break;\n    } else if (opt[0] === '-') {\n      if (!bools.has(opt.replace(/^--?(no-)?/i, ''))) {\n        i++;\n      }\n    } else {\n      cmdIndex = i;\n      break;\n    }\n  }\n\n  if (cmdIndex) {\n    const parsed = parser.parse(argv.slice(0, cmdIndex));\n    const parsedCmd = npa(argv[cmdIndex]);\n    parsed.command = parsed.package ? argv[cmdIndex] : guessCmdName(parsedCmd);\n    parsed.cmdOpts = argv.slice(cmdIndex + 1);\n\n    if (typeof parsed.package === 'string') {\n      parsed.package = [parsed.package];\n    }\n\n    parsed.packageRequested = !!parsed.package;\n    parsed.cmdHadVersion = parsed.package ? false : parsedCmd.name !== parsedCmd.raw;\n    const pkg = parsed.package || [argv[cmdIndex]];\n    parsed.p = parsed.package = pkg.map(p => npa(p).toString());\n    return parsed;\n  } else {\n    const parsed = parser.parse(argv);\n\n    if (typeof parsed.package === 'string') {\n      parsed.package = [parsed.package];\n    }\n\n    if (parsed.call) {\n      const splitCmd = parsed.call.trim().split(/\\s+/);\n      const parsedCmd = npa(splitCmd[0]);\n      parsed.command = parsed.package ? splitCmd[0] : guessCmdName(parsedCmd);\n      parsed.cmdOpts = splitCmd.slice(1);\n      parsed.packageRequested = !!parsed.package;\n      parsed.cmdHadVersion = parsed.package ? false : parsedCmd.name !== parsedCmd.raw;\n      const pkg = parsed.package || [splitCmd[0]];\n      parsed.p = parsed.package = pkg.map(p => npa(p).toString());\n    } else if (hasDashDash) {\n      const splitCmd = parsed._.slice(2);\n\n      const parsedCmd = npa(splitCmd[0]);\n      parsed.command = parsed.package ? splitCmd[0] : guessCmdName(parsedCmd);\n      parsed.cmdOpts = splitCmd.slice(1);\n      parsed.packageRequested = !!parsed.package;\n      parsed.cmdHadVersion = parsed.package ? false : parsedCmd.name !== parsedCmd.raw;\n      const pkg = parsed.package || [splitCmd[0]];\n      parsed.p = parsed.package = pkg.map(p => npa(p).toString());\n    }\n\n    return parsed;\n  }\n}\n\nparseArgs.showHelp = () => yargs.showHelp();\n\nmodule.exports._guessCmdName = guessCmdName;\n\nfunction guessCmdName(spec) {\n  if (typeof spec === 'string') {\n    spec = npa(spec);\n  }\n\n  if (spec.scope) {\n    return spec.name.slice(spec.scope.length + 1);\n  } else if (spec.registry) {\n    return spec.name;\n  } else if (spec.hosted && spec.hosted.project) {\n    return spec.hosted.project;\n  } else if (spec.type === 'git') {\n    const match = spec.fetchSpec.match(/([a-z0-9-]+)(?:\\.git)?$/i);\n    return match[1];\n  } else if (spec.type === 'directory') {\n    return path.basename(spec.fetchSpec);\n  } else if (spec.type === 'file' || spec.type === 'remote') {\n    let ext = path.extname(spec.fetchSpec);\n\n    if (ext === '.gz') {\n      ext = path.extname(path.basename(spec.fetchSpec, ext)) + ext;\n    }\n\n    return path.basename(spec.fetchSpec, ext).replace(/-\\d+\\.\\d+\\.\\d+(?:-[a-z0-9.\\-+]+)?$/i, '');\n  }\n\n  console.error(`Unable to guess a binary name from ${spec.raw}. Please use --package.`);\n  return null;\n}","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/parse-args.js"],"names":["npa","require","path","yargs","usage","module","exports","parseArgs","argv","process","parser","option","alias","type","describe","default","choices","requireArg","version","help","epilogue","opts","getOptions","bools","Set","boolean","cmdIndex","hasDashDash","i","length","opt","has","replace","parsed","parse","slice","parsedCmd","command","package","guessCmdName","cmdOpts","packageRequested","cmdHadVersion","name","raw","pkg","p","map","toString","call","splitCmd","trim","split","_","showHelp","_guessCmdName","spec","scope","registry","hosted","project","match","fetchSpec","basename","ext","extname","console","error"],"mappings":"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","sourcesContent":["'use strict'\n\nconst npa = require('npm-package-arg')\nconst path = require('path')\nconst yargs = require('yargs')\n\nconst usage = `$0 [--package|-p <package>] [--cache <path>] [--no-install] [--userconfig <path>] [-c <string>] [--shell <string>] [--shell-auto-fallback [<shell>]] [--ignore-existing] [--version|-v] [--] <command>[@version] [command-arg]...`\n\nmodule.exports = parseArgs\nfunction parseArgs (argv) {\n  argv = argv || process.argv\n  const parser = yargs\n  .usage(`Execute binaries from npm packages.\\n${usage}`)\n  .option('package', {\n    alias: 'p',\n    type: 'string',\n    describe: 'Package to be installed.'\n  })\n  .option('cache', {\n    type: 'string',\n    describe: 'Location of the npm cache.'\n  })\n  .option('install', {\n    type: 'boolean',\n    describe: 'Skip installation if a package is missing.',\n    default: true\n  })\n  .option('userconfig', {\n    type: 'string',\n    describe: 'Path to user npmrc.'\n  })\n  .option('call', {\n    alias: 'c',\n    type: 'string',\n    describe: 'Execute string as if inside `npm run-script`.'\n  })\n  .option('shell', {\n    alias: 's',\n    type: 'string',\n    describe: 'Shell to execute the command with, if any.',\n    default: false\n  })\n  .option('shell-auto-fallback', {\n    choices: ['', 'bash', 'fish', 'zsh'],\n    describe: 'Generate shell code to use npx as the \"command not found\" fallback.',\n    requireArg: false,\n    type: 'string'\n  })\n  .option('ignore-existing', {\n    describe: 'Ignores existing binaries in $PATH, or in the local project. This forces npx to do a temporary install and use the latest version.',\n    type: 'boolean'\n  })\n  .version()\n  .alias('version', 'v')\n  .help()\n  .alias('help', 'h')\n  .epilogue('For the full documentation, see the manual page for npx(1).')\n\n  const opts = parser.getOptions()\n  const bools = new Set(opts.boolean)\n\n  let cmdIndex\n  let hasDashDash\n  for (let i = 2; i < argv.length; i++) {\n    const opt = argv[i]\n    if (opt === '--') {\n      hasDashDash = true\n      break\n    } else if (opt[0] === '-') {\n      if (!bools.has(opt.replace(/^--?(no-)?/i, ''))) {\n        i++\n      }\n    } else {\n      cmdIndex = i\n      break\n    }\n  }\n  if (cmdIndex) {\n    const parsed = parser.parse(argv.slice(0, cmdIndex))\n    const parsedCmd = npa(argv[cmdIndex])\n    parsed.command = parsed.package\n    ? argv[cmdIndex]\n    : guessCmdName(parsedCmd)\n    parsed.cmdOpts = argv.slice(cmdIndex + 1)\n    if (typeof parsed.package === 'string') {\n      parsed.package = [parsed.package]\n    }\n    parsed.packageRequested = !!parsed.package\n    parsed.cmdHadVersion = parsed.package\n    ? false\n    : parsedCmd.name !== parsedCmd.raw\n    const pkg = parsed.package || [argv[cmdIndex]]\n    parsed.p = parsed.package = pkg.map(p => npa(p).toString())\n    return parsed\n  } else {\n    const parsed = parser.parse(argv)\n    if (typeof parsed.package === 'string') {\n      parsed.package = [parsed.package]\n    }\n    if (parsed.call) {\n      const splitCmd = parsed.call.trim().split(/\\s+/)\n      const parsedCmd = npa(splitCmd[0])\n      parsed.command = parsed.package\n      ? splitCmd[0]\n      : guessCmdName(parsedCmd)\n      parsed.cmdOpts = splitCmd.slice(1)\n      parsed.packageRequested = !!parsed.package\n      parsed.cmdHadVersion = parsed.package\n      ? false\n      : parsedCmd.name !== parsedCmd.raw\n      const pkg = parsed.package || [splitCmd[0]]\n      parsed.p = parsed.package = pkg.map(p => npa(p).toString())\n    } else if (hasDashDash) {\n      const splitCmd = parsed._.slice(2)\n      const parsedCmd = npa(splitCmd[0])\n      parsed.command = parsed.package\n      ? splitCmd[0]\n      : guessCmdName(parsedCmd)\n      parsed.cmdOpts = splitCmd.slice(1)\n      parsed.packageRequested = !!parsed.package\n      parsed.cmdHadVersion = parsed.package\n      ? false\n      : parsedCmd.name !== parsedCmd.raw\n      const pkg = parsed.package || [splitCmd[0]]\n      parsed.p = parsed.package = pkg.map(p => npa(p).toString())\n    }\n    return parsed\n  }\n}\n\nparseArgs.showHelp = () => yargs.showHelp()\n\nmodule.exports._guessCmdName = guessCmdName\nfunction guessCmdName (spec) {\n  if (typeof spec === 'string') { spec = npa(spec) }\n  if (spec.scope) {\n    return spec.name.slice(spec.scope.length + 1)\n  } else if (spec.registry) {\n    return spec.name\n  } else if (spec.hosted && spec.hosted.project) {\n    return spec.hosted.project\n  } else if (spec.type === 'git') {\n    const match = spec.fetchSpec.match(/([a-z0-9-]+)(?:\\.git)?$/i)\n    return match[1]\n  } else if (spec.type === 'directory') {\n    return path.basename(spec.fetchSpec)\n  } else if (spec.type === 'file' || spec.type === 'remote') {\n    let ext = path.extname(spec.fetchSpec)\n    if (ext === '.gz') {\n      ext = path.extname(path.basename(spec.fetchSpec, ext)) + ext\n    }\n    return path.basename(spec.fetchSpec, ext).replace(/-\\d+\\.\\d+\\.\\d+(?:-[a-z0-9.\\-+]+)?$/i, '')\n  }\n\n  console.error(`Unable to guess a binary name from ${spec.raw}. Please use --package.`)\n  return null\n}\n"]},"metadata":{},"sourceType":"script"}