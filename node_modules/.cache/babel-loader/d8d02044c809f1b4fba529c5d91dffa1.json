{"ast":null,"code":"var parse = require('spdx-expression-parse');\n\nvar correct = require('spdx-correct');\n\nvar genericWarning = 'license should be ' + 'a valid SPDX license expression (without \"LicenseRef\"), ' + '\"UNLICENSED\", or ' + '\"SEE LICENSE IN <filename>\"';\nvar fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;\n\nfunction startsWith(prefix, string) {\n  return string.slice(0, prefix.length) === prefix;\n}\n\nfunction usesLicenseRef(ast) {\n  if (ast.hasOwnProperty('license')) {\n    var license = ast.license;\n    return startsWith('LicenseRef', license) || startsWith('DocumentRef', license);\n  } else {\n    return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);\n  }\n}\n\nmodule.exports = function (argument) {\n  var ast;\n\n  try {\n    ast = parse(argument);\n  } catch (e) {\n    var match;\n\n    if (argument === 'UNLICENSED' || argument === 'UNLICENCED') {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        unlicensed: true\n      };\n    } else if (match = fileReferenceRE.exec(argument)) {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        inFile: match[1]\n      };\n    } else {\n      var result = {\n        validForOldPackages: false,\n        validForNewPackages: false,\n        warnings: [genericWarning]\n      };\n      var corrected = correct(argument);\n\n      if (corrected) {\n        result.warnings.push('license is similar to the valid expression \"' + corrected + '\"');\n      }\n\n      return result;\n    }\n  }\n\n  if (usesLicenseRef(ast)) {\n    return {\n      validForNewPackages: false,\n      validForOldPackages: false,\n      spdx: true,\n      warnings: [genericWarning]\n    };\n  } else {\n    return {\n      validForNewPackages: true,\n      validForOldPackages: true,\n      spdx: true\n    };\n  }\n};","map":{"version":3,"sources":["C:/Users/Hp/node_modules/npx/node_modules/validate-npm-package-license/index.js"],"names":["parse","require","correct","genericWarning","fileReferenceRE","startsWith","prefix","string","slice","length","usesLicenseRef","ast","hasOwnProperty","license","left","right","module","exports","argument","e","match","validForOldPackages","validForNewPackages","unlicensed","exec","inFile","result","warnings","corrected","push","spdx"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,uBAAD,CAAnB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,cAAD,CAArB;;AAEA,IAAIE,cAAc,GAChB,uBACA,0DADA,GAEA,mBAFA,GAGA,6BAJF;AAOA,IAAIC,eAAe,GAAG,0BAAtB;;AAEA,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,MAA5B,EAAoC;AAClC,SAAOA,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgBF,MAAM,CAACG,MAAvB,MAAmCH,MAA1C;AACD;;AAED,SAASI,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,MAAIA,GAAG,CAACC,cAAJ,CAAmB,SAAnB,CAAJ,EAAmC;AACjC,QAAIC,OAAO,GAAGF,GAAG,CAACE,OAAlB;AACA,WACER,UAAU,CAAC,YAAD,EAAeQ,OAAf,CAAV,IACAR,UAAU,CAAC,aAAD,EAAgBQ,OAAhB,CAFZ;AAID,GAND,MAMO;AACL,WACEH,cAAc,CAACC,GAAG,CAACG,IAAL,CAAd,IACAJ,cAAc,CAACC,GAAG,CAACI,KAAL,CAFhB;AAID;AACF;;AAEDC,MAAM,CAACC,OAAP,GAAiB,UAASC,QAAT,EAAmB;AAClC,MAAIP,GAAJ;;AAEA,MAAI;AACFA,IAAAA,GAAG,GAAGX,KAAK,CAACkB,QAAD,CAAX;AACD,GAFD,CAEE,OAAOC,CAAP,EAAU;AACV,QAAIC,KAAJ;;AACA,QACEF,QAAQ,KAAK,YAAb,IACAA,QAAQ,KAAK,YAFf,EAGE;AACA,aAAO;AACLG,QAAAA,mBAAmB,EAAE,IADhB;AAELC,QAAAA,mBAAmB,EAAE,IAFhB;AAGLC,QAAAA,UAAU,EAAE;AAHP,OAAP;AAKD,KATD,MASO,IAAIH,KAAK,GAAGhB,eAAe,CAACoB,IAAhB,CAAqBN,QAArB,CAAZ,EAA4C;AACjD,aAAO;AACLG,QAAAA,mBAAmB,EAAE,IADhB;AAELC,QAAAA,mBAAmB,EAAE,IAFhB;AAGLG,QAAAA,MAAM,EAAEL,KAAK,CAAC,CAAD;AAHR,OAAP;AAKD,KANM,MAMA;AACL,UAAIM,MAAM,GAAG;AACXL,QAAAA,mBAAmB,EAAE,KADV;AAEXC,QAAAA,mBAAmB,EAAE,KAFV;AAGXK,QAAAA,QAAQ,EAAE,CAACxB,cAAD;AAHC,OAAb;AAKA,UAAIyB,SAAS,GAAG1B,OAAO,CAACgB,QAAD,CAAvB;;AACA,UAAIU,SAAJ,EAAe;AACbF,QAAAA,MAAM,CAACC,QAAP,CAAgBE,IAAhB,CACE,iDAAiDD,SAAjD,GAA6D,GAD/D;AAGD;;AACD,aAAOF,MAAP;AACD;AACF;;AAED,MAAIhB,cAAc,CAACC,GAAD,CAAlB,EAAyB;AACvB,WAAO;AACLW,MAAAA,mBAAmB,EAAE,KADhB;AAELD,MAAAA,mBAAmB,EAAE,KAFhB;AAGLS,MAAAA,IAAI,EAAE,IAHD;AAILH,MAAAA,QAAQ,EAAE,CAACxB,cAAD;AAJL,KAAP;AAMD,GAPD,MAOO;AACL,WAAO;AACLmB,MAAAA,mBAAmB,EAAE,IADhB;AAELD,MAAAA,mBAAmB,EAAE,IAFhB;AAGLS,MAAAA,IAAI,EAAE;AAHD,KAAP;AAKD;AACF,CApDD","sourcesContent":["var parse = require('spdx-expression-parse');\nvar correct = require('spdx-correct');\n\nvar genericWarning = (\n  'license should be ' +\n  'a valid SPDX license expression (without \"LicenseRef\"), ' +\n  '\"UNLICENSED\", or ' +\n  '\"SEE LICENSE IN <filename>\"'\n);\n\nvar fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;\n\nfunction startsWith(prefix, string) {\n  return string.slice(0, prefix.length) === prefix;\n}\n\nfunction usesLicenseRef(ast) {\n  if (ast.hasOwnProperty('license')) {\n    var license = ast.license;\n    return (\n      startsWith('LicenseRef', license) ||\n      startsWith('DocumentRef', license)\n    );\n  } else {\n    return (\n      usesLicenseRef(ast.left) ||\n      usesLicenseRef(ast.right)\n    );\n  }\n}\n\nmodule.exports = function(argument) {\n  var ast;\n\n  try {\n    ast = parse(argument);\n  } catch (e) {\n    var match\n    if (\n      argument === 'UNLICENSED' ||\n      argument === 'UNLICENCED'\n    ) {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        unlicensed: true\n      };\n    } else if (match = fileReferenceRE.exec(argument)) {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        inFile: match[1]\n      };\n    } else {\n      var result = {\n        validForOldPackages: false,\n        validForNewPackages: false,\n        warnings: [genericWarning]\n      };\n      var corrected = correct(argument);\n      if (corrected) {\n        result.warnings.push(\n          'license is similar to the valid expression \"' + corrected + '\"'\n        );\n      }\n      return result;\n    }\n  }\n\n  if (usesLicenseRef(ast)) {\n    return {\n      validForNewPackages: false,\n      validForOldPackages: false,\n      spdx: true,\n      warnings: [genericWarning]\n    };\n  } else {\n    return {\n      validForNewPackages: true,\n      validForOldPackages: true,\n      spdx: true\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}